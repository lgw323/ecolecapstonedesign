<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>알고리즘 7문제: Java, Python, JS 풀이 분석 (WEEK4)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body class="bg-white text-black">

    <div id="presentation-root" class="relative w-screen h-screen">
        <div id="presentation-container" class="w-full h-full bg-white flex flex-col overflow-hidden">
        </div>
    </div>

    <div id="modal-backdrop"></div>
    <div id="modal-content">
        <button id="modal-close-btn">&times;</button>
        <div id="explanation-container">
        </div>
    </div>

    <script>
        const presentationData_part1 = [
            {
                type: 'title',
                title: '알고리즘 7문제 (4주차)',
                author: '경성대학교 소프트웨어학과',
                author_detail: '2021663046 이건우'
            },
            {
                type: 'toc',
                title: '발표 순서 (4주차)',
                items: [
                    '특정 거리의 도시 찾기 (BOJ 18352)',
                    '이분 그래프 (BOJ 1707)',
                    '집합의 표현 (BOJ 1717)',
                    '줄 세우기 (BOJ 2252)',
                    '게임 개발 (BOJ 1516)',
                    '최단경로 (BOJ 1753)',
                    'K번째 최단 경로 (BOJ 1854)'
                ]
            },
            {
                type: 'problem_detail',
                title: '문제 1: 특정 거리의 도시 찾기 (BOJ 18352)',
                problem: '어떤 나라에는 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다. 이때 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시의 번호를 출력하는 프로그램을 작성하시오.',
                input: '첫째 줄에 도시의 개수 N, 도로의 개수 M, 거리 정보 K, 출발 도시의 번호 X가 주어진다. (2 ≤ N ≤ 300,000, 1 ≤ M ≤ 1,000,000, 1 ≤ K ≤ 300,000, 1 ≤ X ≤ N) 둘째 줄부터 M개의 줄에 걸쳐서 두 개의 자연수 A, B가 공백을 기준으로 구분되어 주어진다. 이는 A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 의미이다. (A ≠ B) 자기 자신으로 오는 도로는 없다.',
                output: 'X로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 K인 모든 도시의 번호를 한 줄에 하나씩 오름차순으로 출력한다. 만약 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력한다.',
                example_input_1: `4 4 2 1
1 2
1 3
2 3
2 4`,
                example_output_1: `4`
            },
            {
                type: 'problem',
                title: '알고리즘: BFS (너비 우선 탐색)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class bj1_18352 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());

        ArrayList<Integer>[] adjList = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            adjList[i] = new ArrayList<>();
        }

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            adjList[u].add(v);
        }

        int[] distance = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            distance[i] = -1;
        }

        Queue<Integer> queue = new LinkedList<>();
        queue.add(x);
        distance[x] = 0;

        while (!queue.isEmpty()) {
            int current = queue.poll();

            for (int neighbor : adjList[current]) {
                if (distance[neighbor] == -1) {
                    distance[neighbor] = distance[current] + 1;
                    queue.add(neighbor);
                }
            }
        }

        ArrayList<Integer> result = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (distance[i] == k) {
                result.add(i);
            }
        }

        if (result.isEmpty()) {
            System.out.println(-1);
        } else {
            Collections.sort(result);
            StringBuilder sb = new StringBuilder();
            for (int city : result) {
                sb.append(city).append("\\n");
            }
            System.out.print(sb);
        }
    }
}`,
                    python: `import sys
from collections import deque

input = sys.stdin.readline
n, m, k, x = map(int, input().split())
adjList = [[] for _ in range(n + 1)]

for _ in range(m):
    u, v = map(int, input().split())
    adjList[u].append(v)

distance = [-1] * (n + 1)
queue = deque([x])
distance[x] = 0

while queue:
    current = queue.popleft()
    for neighbor in adjList[current]:
        if distance[neighbor] == -1:
            distance[neighbor] = distance[current] + 1
            queue.append(neighbor)

result = []
for i in range(1, n + 1):
    if distance[i] == k:
        result.append(i)

if not result:
    print(-1)
else:
    result.sort()
    for city in result:
        print(city)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const [n, m, k, x] = input[0].split(' ').map(Number);
const adjList = Array.from({ length: n + 1 }, () => []);

for (let i = 1; i <= m; i++) {
    const [u, v] = input[i].split(' ').map(Number);
    adjList[u].push(v);
}

const distance = new Array(n + 1).fill(-1);
const queue = [];
let head = 0;

queue.push(x);
distance[x] = 0;

while (head < queue.length) {
    const current = queue[head++];

    for (const neighbor of adjList[current]) {
        if (distance[neighbor] === -1) {
            distance[neighbor] = distance[current] + 1;
            queue.push(neighbor);
        }
    }
}

const result = [];
for (let i = 1; i <= n; i++) {
    if (distance[i] === k) {
        result.push(i);
    }
}

if (result.length === 0) {
    console.log(-1);
} else {
    result.sort((a, b) => a - b);
    console.log(result.join('\\n'));
}`
                }
            },
            {
                type: 'problem_detail',
                title: '문제 2: 이분 그래프 (BOJ 1707)',
                problem: '그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다. 그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.',
                input: '입력은 여러 개의 테스트 케이스로 구성되어 있는데, 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스의 첫째 줄에는 그래프의 정점의 개수 V와 간선의 개수 E가 빈 칸을 사이에 두고 순서대로 주어진다. 각 정점에는 1부터 V까지 차례로 번호가 붙어 있다. 이어서 E개의 줄에 걸쳐 간선에 대한 정보가 주어지는데, 각 줄에 인접한 두 정점의 번호 u, v가 빈 칸을 사이에 두고 주어진다.',
                output: 'K개의 줄에 걸쳐 입력으로 주어진 그래프가 이분 그래프이면 YES, 아니면 NO를 순서대로 출력한다.',
                example_input_1: `2
3 2
1 3
2 3
4 4
1 2
2 3
3 4
4 1`,
                example_output_1: `YES
NO`
            },
            {
                type: 'problem',
                title: '알고리즘: BFS 또는 DFS',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class bj2_1707 {

    static ArrayList<Integer>[] adjList;
    static int[] groups;
    static final int GROUP_A = 1;
    static final int GROUP_B = 2;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int k = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();

        for (int t = 0; t < k; t++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int v = Integer.parseInt(st.nextToken());
            int e = Integer.parseInt(st.nextToken());

            adjList = new ArrayList[v + 1];
            groups = new int[v + 1];
            for (int i = 1; i <= v; i++) {
                adjList[i] = new ArrayList<>();
            }

            for (int i = 0; i < e; i++) {
                st = new StringTokenizer(br.readLine());
                int u = Integer.parseInt(st.nextToken());
                int w = Integer.parseInt(st.nextToken());
                adjList[u].add(w);
                adjList[w].add(u);
            }

            boolean isBipartite = true;
            for (int i = 1; i <= v; i++) {
                if (groups[i] == 0) {
                    if (!bfsCheck(i)) {
                        isBipartite = false;
                        break;
                    }
                }
            }
            sb.append(isBipartite ? "YES" : "NO").append("\\n");
        }
        System.out.print(sb);
    }

    private static boolean bfsCheck(int startNode) {
        Queue<Integer> queue = new LinkedList<>();
        queue.add(startNode);
        groups[startNode] = GROUP_A;

        while (!queue.isEmpty()) {
            int current = queue.poll();
            int nextGroup = (groups[current] == GROUP_A) ? GROUP_B : GROUP_A;

            for (int neighbor : adjList[current]) {
                if (groups[neighbor] == 0) {
                    groups[neighbor] = nextGroup;
                    queue.add(neighbor);
                } else if (groups[neighbor] == groups[current]) {
                    return false;
                }
            }
        }
        return true;
    }
}`,
                    python: `import sys
from collections import deque

input = sys.stdin.readline
# sys.setrecursionlimit(200000)

def bfs(start_node, v, adjList, groups):
    queue = deque([start_node])
    groups[start_node] = 1

    while queue:
        current = queue.popleft()
        next_group = 2 if groups[current] == 1 else 1

        for neighbor in adjList[current]:
            if groups[neighbor] == 0:
                groups[neighbor] = next_group
                queue.append(neighbor)
            elif groups[neighbor] == groups[current]:
                return False
    return True

k = int(input())
for _ in range(k):
    v, e = map(int, input().split())
    adjList = [[] for _ in range(v + 1)]
    groups = [0] * (v + 1)

    for _ in range(e):
        u, w = map(int, input().split())
        adjList[u].append(w)
        adjList[w].append(u)

    is_bipartite = True
    for i in range(1, v + 1):
        if groups[i] == 0:
            if not bfs(i, v, adjList, groups):
                is_bipartite = False
                break

    print("YES" if is_bipartite else "NO")`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

let lineIndex = 0;
const k = Number(input[lineIndex++]);
const GROUP_A = 1;
const GROUP_B = 2;
let result = '';

function isBipartite(startNode, v, adjList, groups) {
    const queue = [];
    let head = 0;
    queue.push(startNode);
    groups[startNode] = GROUP_A;

    while (head < queue.length) {
        const current = queue[head++];
        const nextGroup = (groups[current] === GROUP_A) ? GROUP_B : GROUP_A;

        for (const neighbor of adjList[current]) {
            if (groups[neighbor] === 0) {
                groups[neighbor] = nextGroup;
                queue.push(neighbor);
            } else if (groups[neighbor] === groups[current]) {
                return false;
            }
        }
    }
    return true;
}

for (let t = 0; t < k; t++) {
    const [v, e] = input[lineIndex++].split(' ').map(Number);
    const adjList = Array.from({ length: v + 1 }, () => []);
    const groups = new Array(v + 1).fill(0);

    for (let i = 0; i < e; i++) {
        const [u, w] = input[lineIndex++].split(' ').map(Number);
        adjList[u].push(w);
        adjList[w].push(u);
    }

    let isBipartiteGraph = true;
    for (let i = 1; i <= v; i++) {
        if (groups[i] === 0) {
            if (!isBipartite(i, v, adjList, groups)) {
                isBipartiteGraph = false;
                break;
            }
        }
    }
    result += (isBipartiteGraph ? "YES" : "NO") + "\\n";
}

console.log(result.trim());`
                }
            },
            {
                type: 'problem_detail',
                title: '문제 3: 집합의 표현 (BOJ 1717)',
                problem: '초기에 {0}, {1}, ..., {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.',
                input: '첫째 줄에 n(1 ≤ n ≤ 1,000,000), m(1 ≤ m ≤ 100,000)이 주어진다. m은 입력으로 주어지는 연산의 개수이다. 다음 m개의 줄에는 각각의 연산이 주어진다. 합집합은 0 a b의 형태로 입력이 주어진다. 이는 a가 포함되어 있는 집합과, b가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 1 a b의 형태로 입력이 주어진다. 이는 a와 b가 같은 집합에 포함되어 있는지를 확인하는 연산이다.',
                output: '1로 시작하는 입력에 대해서, a와 b가 같은 집합에 포함되어 있으면 "YES" 또는 "yes"를, 그렇지 않으면 "NO" 또는 "no"를 한 줄에 하나씩 출력한다.',
                example_input_1: `7 8
0 1 3
1 1 7
0 7 6
1 7 1
0 3 7
0 4 2
0 5 4
1 1 7`,
                example_output_1: `NO
NO
YES`,
                problemId: 'bj1717'
            },
            {
                type: 'problem',
                title: '알고리즘: Union-Find (분리 집합)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj3_1717 {
    static int[] parent;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        parent = new int[n + 1];
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int op = Integer.parseInt(st.nextToken());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            if (op == 0) {
                union(a, b);
            } else {
                if (find(a) == find(b)) {
                    sb.append("YES\\n");
                } else {
                    sb.append("NO\\n");
                }
            }
        }
        System.out.print(sb);
    }

    private static int find(int i) {
        if (parent[i] == i) {
            return i;
        }
        return parent[i] = find(parent[i]);
    }

    private static void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);
        if (rootA != rootB) {
            parent[rootB] = rootA;
        }
    }
}`,
                    python: `import sys
sys.setrecursionlimit(10**6)
input = sys.stdin.readline

def find(i):
    if parent[i] == i:
        return i
    parent[i] = find(parent[i])
    return parent[i]

def union(a, b):
    rootA = find(a)
    rootB = find(b)
    if rootA != rootB:
        parent[rootB] = rootA

n, m = map(int, input().split())
parent = list(range(n + 1))

for _ in range(m):
    op, a, b = map(int, input().split())
    if op == 0:
        union(a, b)
    else:
        if find(a) == find(b):
            print("YES")
        else:
            print("NO")`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const [n, m] = input[0].split(' ').map(Number);
const parent = Array.from({ length: n + 1 }, (_, i) => i);

function find(i) {
    if (parent[i] === i) {
        return i;
    }
    return parent[i] = find(parent[i]);
}

function union(a, b) {
    const rootA = find(a);
    const rootB = find(b);
    if (rootA !== rootB) {
        parent[rootB] = rootA;
    }
}

let result = '';
for (let i = 1; i <= m; i++) {
    const [op, a, b] = input[i].split(' ').map(Number);
    if (op === 0) {
        union(a, b);
    } else {
        if (find(a) === find(b)) {
            result += "YES\\n";
        } else {
            result += "NO\\n";
        }
    }
}

console.log(result.trim());`
                }
            },
        ];

        const explanationData = {
            'bj1717': {
                title: 'BOJ 1717: 집합 표현 - 쉽고 빠른 Union-Find!',
                steps: [
                    {
                        step: 1,
                        icon: '🎯',
                        title: "뭘 하려는 거지? - 문제 상황 쉽게 보기",
                        content: `<p>0번부터 N번까지 번호표를 가진 사람들이 있어요. 처음엔 다 <strong class='text-blue-600'>혼자서 자기 그룹</strong>이에요.</p>
                                  <p>여기에 두 가지 지시가 내려와요:</p>
                                  <ul class='list-disc list-inside ml-4 mt-2 space-y-1'>
                                      <li><strong class='text-red-600'>지시 0 (합치기): "0 a b"</strong> <br>➡️ a가 속한 그룹과 b가 속한 그룹을 <strong class='text-red-600'>하나로 합쳐라!</strong> (이제 한 가족!)</li>
                                      <li><strong class='text-green-600'>지시 1 (확인): "1 a b"</strong> <br>➡️ a랑 b가 <strong class='text-green-600'>같은 그룹인지 확인해봐!</strong> (맞으면 YES, 틀리면 NO)</li>
                                  </ul>
                                  <p class="mt-4 p-4 bg-yellow-100 border border-yellow-300 rounded-lg text-yellow-800"><strong>핵심 목표:</strong> 이 '합치기'와 '확인하기'를 <strong class='font-bold'>아주 아주 빠르게</strong> 처리하는 방법을 찾는 거예요!</p>`
                    },
                    {
                        step: 2,
                        icon: '🐢',
                        title: "단순한 생각 (하지만 느려!) - 이름표 붙이기",
                        content: `<p>각 사람에게 '넌 1번 그룹', '넌 2번 그룹' 이렇게 이름표(배열 값)를 붙여주면 어떨까요?</p>
                                  <ul class='list-disc list-inside ml-4 mt-2 space-y-1'>
                                      <li><strong class='text-green-600'>확인하기 (1 a b):</strong> a 이름표랑 b 이름표 비교만 하면 되니 <strong class='text-green-600'>엄청 빨라요!</strong> 👍</li>
                                      <li><strong class='text-red-600'>합치기 (0 a b):</strong> 이게 문제예요! 😱 b 그룹 이름표를 가진 <strong class='text-red-600'>모든 사람을 찾아서</strong> a 그룹 이름표로 바꿔줘야 해요. 그룹이 크면 너무 오래 걸리겠죠? (시간 초과 확정!)</li>
                                  </ul>`
                    },
                    {
                        step: 3,
                        icon: '💡',
                        title: "똑똑한 생각! - 각 그룹에 '대장'을 정하자!",
                        content: `<p>매번 이름표를 바꾸는 대신, 각 그룹(무리)마다 딱 한 명의 <strong class='text-purple-600'>'대장(대표, 루트)'</strong>을 정하는 거예요.</p>
                                  <p>내가 어느 그룹인지 알려면? <strong class='font-bold'>우리 그룹 대장이 누군지만 알면 돼요!</strong></p>
                                  <p class="mt-2 p-3 bg-gray-100 rounded-md"><strong>초기 상태:</strong> 처음엔 모두 혼자니까, <strong class='text-purple-600'>각자 자기 자신이 대장</strong>이에요.</p>`
                    },
                    {
                        step: 4,
                        icon: '❓',
                        title: "내 대장은 누구? - `find` 연산 (대장 찾기)",
                        content: `<p>내 대장을 어떻게 찾을까요? 간단해요!</p>
                                  <ol class='list-decimal list-inside ml-4 mt-2 space-y-1'>
                                      <li>나의 '바로 위 상사'에게 물어봐요. (<code>parent</code> 배열 참조)</li>
                                      <li>그 상사가 자기 자신을 가리키면(자기가 대장이면), 그 사람이 <strong class='text-purple-600'>최종 대장(루트)!</strong> 찾았다! 🎉</li>
                                      <li>아니라면, 그 상사에게 다시 1번부터 물어보라고 시켜요. (재귀 호출)</li>
                                  </ol>
                                  <p class="mt-3">마치 회사 조직도에서 맨 위 사장님을 찾아 올라가는 것과 같아요.</p>`,
                        code_title: "기본적인 `find` 코드 (최적화 전)",
                        code: `int find_simple(int i) {
    if (parent[i] == i) {
        return i;
    }
    return find_simple(parent[i]);
}`,
                        code_explanation: `<p><code>parent</code> 배열을 따라 계속 올라가서, 자기 자신을 가리키는 노드(루트)를 찾을 때까지 재귀적으로 호출하는 방식이에요.</p>`
                    },
                    {
                        step: 5,
                        icon: '🤝',
                        title: "두 무리 합체! - `union` 연산 (무리 합치기)",
                        content: `<p>a 그룹과 b 그룹을 합치는 건 더 쉬워요!</p>
                                  <ol class='list-decimal list-inside ml-4 mt-2 space-y-1'>
                                      <li>a의 최종 대장 (<code>rootA</code>)을 찾아요. (<code>find(a)</code>)</li>
                                      <li>b의 최종 대장 (<code>rootB</code>)을 찾아요. (<code>find(b)</code>)</li>
                                      <li>만약 두 대장이 <strong class='text-red-600'>다르다면</strong> (같은 그룹이 아니라면), 한쪽 대장의 '바로 위 상사'를 다른 쪽 대장으로 <strong class='text-blue-600'>바꿔버려요!</strong> (예: <code>parent[rootB] = rootA</code>)</li>
                                  </ol>
                                  <p class="mt-3">이제 b 그룹 사람들도 대장을 찾아 올라가다 보면 결국 a 그룹 대장까지 가게 되니, 두 그룹이 하나로 합쳐진 거죠!</p>`,
                        code_title: "`union` 코드",
                        code: `void union(int a, int b) {
    int rootA = find(a);
    int rootB = find(b);

    if (rootA != rootB) {
        parent[rootB] = rootA;
    }
}`,
                        code_explanation: `<p>각각의 대장을 찾고, 다를 경우 한쪽 대장의 <code>parent</code> 값을 다른 쪽 대장 번호로 업데이트하여 연결해요.</p>`
                    },
                    {
                        step: 6,
                        icon: '✅',
                        title: "같은 무리인지 확인?",
                        content: `<p>'1 a b' 지시가 오면 어떻게 할까요?</p>
                                  <p class='text-center text-2xl font-bold my-4 p-4 bg-green-100 border border-green-300 rounded-lg text-green-800'>
                                      a의 대장 (<code>find(a)</code>)과 <br>
                                      b의 대장 (<code>find(b)</code>)을 찾아서 <br>
                                      <strong class='text-red-600'>같은 사람인지 비교</strong>하면 끝!
                                  </p>
                                  <p>같으면 "YES", 다르면 "NO" 예요.</p>`
                    },
                    {
                        step: 7,
                        icon: '🚀',
                        title: "더 빠르게! - '경로 압축' 최적화",
                        content: `<p><code>find</code> 연산으로 대장을 찾아 올라가는 길이 너무 길면(트리가 세로로 길면) 시간이 걸릴 수 있어요. 이걸 더 빠르게 하는 마법이 <strong class='text-orange-600'>'경로 압축(Path Compression)'</strong>이에요!</p>
                                  <p>대장을 찾는 과정에서 만났던 <strong class='font-bold'>모든 중간 간부들</strong>에게, 최종 대장을 <strong class='text-red-600'>직속 상사</strong>로 바로 연결해주는 거예요!</p>
                                  <p class="mt-3 p-3 bg-blue-50 border border-blue-200 rounded-md">"사장님 찾았니? 그럼 이제부터 너도 사장님 직속이야!" 하고 알려주는 거죠.</p>
                                  <p class="mt-2">이렇게 하면 다음번에 대장을 찾을 때는 중간 과정을 다 건너뛰고 <strong class='font-bold'>한 번에</strong> 최종 대장을 찾을 수 있어요.</p>`,
                        code_title: "`find` 코드 (경로 압축 적용!)",
                        code: `int find(int i) {
    if (parent[i] == i) {
        return i;
    }
    return parent[i] = find(parent[i]);
}`,
                        code_explanation: `<p>재귀 호출에서 반환된 최종 대장(루트) 값을 현재 노드 <code>i</code>의 <code>parent</code> 값으로 <strong class='text-red-600'>직접 업데이트</strong>하는 부분이 경로 압축의 핵심이에요!</p>`
                    },
                    {
                        step: 8,
                        icon: '🎉',
                        title: "결론: 그래서 왜 이게 좋은데?",
                        content: `<p>이 '대장 시스템(Union-Find)'에 '경로 압축' 기술까지 사용하면, '합치기(<code>union</code>)'와 '대장 찾기/확인(<code>find</code>)' 연산 모두 <strong class='text-green-700 font-bold'>정~~~말 빨라져요!</strong></p>
                                  <p>거의 <strong class='text-green-700'>O(1)</strong>, 즉 상수 시간에 가깝게 동작해서, 수백만 번의 연산도 눈 깜짝할 사이에 처리할 수 있게 되는 거죠.</p>
                                  <p class="mt-4 p-4 bg-purple-100 border border-purple-300 rounded-lg text-purple-800">그래서 '집합을 합치고 확인하는' 종류의 문제에서는 <strong class='font-bold'>Union-Find가 최고의 선택</strong>이랍니다!</p>`
                    }
                ]
            }
        };

        let currentExplanationStep = 0;
        let totalExplanationSteps = 0;
        let currentExplanationData = null;

        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalContent = document.getElementById('modal-content');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const explanationContainer = document.getElementById('explanation-container');

        function openModal(problemId) {
            currentExplanationData = explanationData[problemId];
            if (currentExplanationData && currentExplanationData.steps) {
                totalExplanationSteps = currentExplanationData.steps.length;
                currentExplanationStep = 0;
                renderModalStep();
                modalBackdrop.style.display = 'block';
                modalContent.style.display = 'block';
                modalContent.scrollTop = 0;
                document.body.style.overflow = 'hidden';
            }
        }

        function renderModalStep() {
            if (!currentExplanationData || currentExplanationStep >= totalExplanationSteps || currentExplanationStep < 0) return;

            const stepData = currentExplanationData.steps[currentExplanationStep];
            let contentHtml = `
                <h1 class="text-5xl font-bold text-gray-800 mb-6">${currentExplanationData.title}</h1>
                <div class="explanation-step active">
                    <div class="mb-10 bg-white p-8 rounded-xl shadow-lg border border-gray-200">
                        <h2 class="text-4xl font-bold mb-6 flex items-center text-gray-700">
                            <span class="text-5xl mr-5">${stepData.icon}</span>
                            <span class="text-gray-400 mr-4">STEP ${stepData.step}/${totalExplanationSteps}:</span>
                            ${stepData.title}
                        </h2>
                        <div class="prose max-w-none prose-xl prose-p:my-3 prose-li:my-2">
                            ${stepData.content || ''}
                        </div>
                `;

            if (stepData.code || stepData.code_explanation) {
                contentHtml += `<div class="mt-8 grid grid-cols-1 ${stepData.code && stepData.code_explanation ? 'lg:grid-cols-2' : ''} gap-6 items-start">`;
                if (stepData.code) {
                    contentHtml += `
                        <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-md p-4 text-lg overflow-auto">
                            ${stepData.code_title ? `<h3 class="text-xl font-semibold text-gray-300 mb-3">${stepData.code_title}</h3>` : ''}
                            <pre><code class="language-java">${stepData.code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>
                         </div>`;
                }
                if (stepData.code_explanation) {
                    contentHtml += `
                        <div class="bg-sky-50 p-6 rounded-xl border border-sky-200 text-sky-800 prose prose-xl">
                             ${stepData.code_explanation}
                        </div>`;
                }
                contentHtml += `</div>`;
            }

            contentHtml += `</div></div>`;

            contentHtml += `
                <div id="modal-pagination">
                    <button id="modal-prev-btn" class="modal-nav-btn" ${currentExplanationStep === 0 ? 'disabled' : ''}>◀ 이전</button>
                    <span id="modal-step-indicator">${currentExplanationStep + 1} / ${totalExplanationSteps}</span>
                    <button id="modal-next-btn" class="modal-nav-btn" ${currentExplanationStep === totalExplanationSteps - 1 ? 'disabled' : ''}>다음 ▶</button>
                </div>
            `;

            explanationContainer.innerHTML = contentHtml;

            explanationContainer.querySelectorAll('pre code').forEach(block => {
                hljs.highlightElement(block);
            });

            document.getElementById('modal-prev-btn').addEventListener('click', prevModalStep);
            document.getElementById('modal-next-btn').addEventListener('click', nextModalStep);
        }

        const presentationData_part2 = [
            {
                type: 'problem_detail',
                title: '문제 4: 줄 세우기 (BOJ 2252)',
                problem: 'N명의 학생들을 키 순서대로 줄을 세우려고 한다. 일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.',
                input: '첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 회수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.',
                output: '첫째 줄에 학생들을 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.',
                example_input_1: `3 2
1 3
2 3`,
                example_output_1: `1 2 3`
            },
            {
                type: 'problem',
                title: '알고리즘: 위상 정렬 (Topological Sort)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class bj4_2252 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        ArrayList<Integer>[] adjList = new ArrayList[n + 1];
        int[] inDegree = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            adjList[i] = new ArrayList<>();
        }

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            adjList[a].add(b);
            inDegree[b]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        StringBuilder sb = new StringBuilder();
        while (!queue.isEmpty()) {
            int current = queue.poll();
            sb.append(current).append(" ");

            for (int neighbor : adjList[current]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    queue.add(neighbor);
                }
            }
        }
        System.out.println(sb.toString().trim());
    }
}`,
                    python: `import sys
from collections import deque

input = sys.stdin.readline
n, m = map(int, input().split())

adjList = [[] for _ in range(n + 1)]
inDegree = [0] * (n + 1)

for _ in range(m):
    a, b = map(int, input().split())
    adjList[a].append(b)
    inDegree[b] += 1

queue = deque()
for i in range(1, n + 1):
    if inDegree[i] == 0:
        queue.append(i)

result = []
while queue:
    current = queue.popleft()
    result.append(current)

    for neighbor in adjList[current]:
        inDegree[neighbor] -= 1
        if inDegree[neighbor] == 0:
            queue.append(neighbor)

print(*result)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const [n, m] = input[0].split(' ').map(Number);
const adjList = Array.from({ length: n + 1 }, () => []);
const inDegree = new Array(n + 1).fill(0);

for (let i = 1; i <= m; i++) {
    const [a, b] = input[i].split(' ').map(Number);
    adjList[a].push(b);
    inDegree[b]++;
}

const queue = [];
let head = 0;
for (let i = 1; i <= n; i++) {
    if (inDegree[i] === 0) {
        queue.push(i);
    }
}

const result = [];
while (head < queue.length) {
    const current = queue[head++];
    result.push(current);

    for (const neighbor of adjList[current]) {
        inDegree[neighbor]--;
        if (inDegree[neighbor] === 0) {
            queue.push(neighbor);
        }
    }
}

console.log(result.join(' '));`
                }
            },
            {
                type: 'problem_detail',
                title: '문제 5: 게임 개발 (BOJ 1516)',
                problem: '숌은 각 건물을 짓는데 걸리는 최소 시간을 알고 싶어 한다. 어떤 건물을 짓기 위해서는 특정 건물을 먼저 지어야 할 수도 있다. 이 선행 관계와 각 건물 건설 시간이 주어졌을 때, 각 건물이 완성되기까지 걸리는 최소 시간을 구하시오.',
                input: '첫째 줄에 건물의 종류 수 N (1 ≤ N ≤ 500)이 주어진다. 다음 N개의 줄에는 각 건물을 짓는데 걸리는 시간과 그 건물을 짓기 위해 먼저 지어져야 하는 건물의 번호들이 주어진다. 건물의 번호는 1부터 N까지이다. 각 줄은 -1로 끝난다.',
                output: 'N개의 각 건물이 완성되기까지 걸리는 최소 시간을 한 줄에 하나씩 출력한다.',
                example_input_1: `5
10 -1
10 1 -1
4 1 -1
4 3 1 -1
3 3 -1`,
                example_output_1: `10
20
14
18
17`
            },
            {
                type: 'problem',
                title: '알고리즘: 위상 정렬 + DP',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class bj5_1516 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        ArrayList<Integer>[] adjList = new ArrayList[n + 1];
        int[] inDegree = new int[n + 1];
        int[] buildTime = new int[n + 1];
        int[] resultTime = new int[n + 1];

        for (int i = 1; i <= n; i++) {
            adjList[i] = new ArrayList<>();
        }

        for (int i = 1; i <= n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            buildTime[i] = Integer.parseInt(st.nextToken());
            resultTime[i] = buildTime[i];

            while (true) {
                int pre = Integer.parseInt(st.nextToken());
                if (pre == -1) break;
                adjList[pre].add(i);
                inDegree[i]++;
            }
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= n; i++) {
            if (inDegree[i] == 0) {
                queue.add(i);
            }
        }

        while (!queue.isEmpty()) {
            int current = queue.poll();

            for (int next : adjList[current]) {
                resultTime[next] = Math.max(resultTime[next], resultTime[current] + buildTime[next]);
                inDegree[next]--;

                if (inDegree[next] == 0) {
                    queue.add(next);
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= n; i++) {
            sb.append(resultTime[i]).append("\\n");
        }
        System.out.print(sb);
    }
}`,
                    python: `import sys
from collections import deque

input = sys.stdin.readline
n = int(input())

adjList = [[] for _ in range(n + 1)]
inDegree = [0] * (n + 1)
buildTime = [0] * (n + 1)
resultTime = [0] * (n + 1)

for i in range(1, n + 1):
    line = list(map(int, input().split()))
    buildTime[i] = line[0]
    resultTime[i] = line[0]
    for j in range(1, len(line) - 1):
        pre = line[j]
        adjList[pre].append(i)
        inDegree[i] += 1

queue = deque()
for i in range(1, n + 1):
    if inDegree[i] == 0:
        queue.append(i)

while queue:
    current = queue.popleft()
    for next_node in adjList[current]:
        resultTime[next_node] = max(
            resultTime[next_node], resultTime[current] + buildTime[next_node]
        )
        inDegree[next_node] -= 1
        if inDegree[next_node] == 0:
            queue.append(next_node)

for i in range(1, n + 1):
    print(resultTime[i])`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const n = Number(input[0]);
const adjList = Array.from({ length: n + 1 }, () => []);
const inDegree = new Array(n + 1).fill(0);
const buildTime = new Array(n + 1).fill(0);
const resultTime = new Array(n + 1).fill(0);

for (let i = 1; i <= n; i++) {
    const line = input[i].split(' ').map(Number);
    buildTime[i] = line[0];
    resultTime[i] = line[0];

    for (let j = 1; j < line.length - 1; j++) {
        const pre = line[j];
        adjList[pre].push(i);
        inDegree[i]++;
    }
}

const queue = [];
let head = 0;
for (let i = 1; i <= n; i++) {
    if (inDegree[i] === 0) {
        queue.push(i);
    }
}

while (head < queue.length) {
    const current = queue[head++];

    for (const next of adjList[current]) {
        resultTime[next] = Math.max(resultTime[next], resultTime[current] + buildTime[next]);
        inDegree[next]--;

        if (inDegree[next] === 0) {
            queue.push(next);
        }
    }
}

let resultOutput = '';
for (let i = 1; i <= n; i++) {
    resultOutput += resultTime[i] + '\\n';
}
console.log(resultOutput.trim());`
                }
            },
            {
                type: 'problem_detail',
                title: '문제 6: 최단경로 (BOJ 1753)',
                problem: '방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.',
                input: '첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.',
                output: '첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.',
                example_input_1: `5 6
1
5 1 1
1 2 2
1 3 3
2 3 4
2 4 5
3 4 6`,
                example_output_1: `0
2
3
7
INF`
            },
            {
                type: 'problem',
                title: '알고리즘: 다익스트라 (Dijkstra)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class bj6_1753 {

    static class Node implements Comparable<Node> {
        int node;
        int weight;

        Node(int node, int weight) {
            this.node = node;
            this.weight = weight;
        }

        @Override
        public int compareTo(Node o) {
            return this.weight - o.weight;
        }
    }

    static final int INF = Integer.MAX_VALUE;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int v = Integer.parseInt(st.nextToken());
        int e = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(br.readLine());

        ArrayList<Node>[] adjList = new ArrayList[v + 1];
        int[] dist = new int[v + 1];

        for (int i = 1; i <= v; i++) {
            adjList[i] = new ArrayList<>();
            dist[i] = INF;
        }

        for (int i = 0; i < e; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            int weight = Integer.parseInt(st.nextToken());
            adjList[u].add(new Node(w, weight));
        }

        PriorityQueue<Node> pq = new PriorityQueue<>();
        dist[k] = 0;
        pq.add(new Node(k, 0));

        while (!pq.isEmpty()) {
            Node current = pq.poll();

            if (current.weight > dist[current.node]) {
                continue;
            }

            for (Node next : adjList[current.node]) {
                if (dist[next.node] > dist[current.node] + next.weight) {
                    dist[next.node] = dist[current.node] + next.weight;
                    pq.add(new Node(next.node, dist[next.node]));
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= v; i++) {
            if (dist[i] == INF) {
                sb.append("INF\\n");
            } else {
                sb.append(dist[i]).append("\\n");
            }
        }
        System.out.print(sb);
    }
}`,
                    python: `import sys
import heapq

input = sys.stdin.readline
v, e = map(int, input().split())
k = int(input())

adjList = [[] for _ in range(v + 1)]
dist = [float("inf")] * (v + 1)

for _ in range(e):
    u, w, weight = map(int, input().split())
    adjList[u].append((w, weight))

pq = []
dist[k] = 0
heapq.heappush(pq, (0, k))

while pq:
    current_weight, current_node = heapq.heappop(pq)

    if current_weight > dist[current_node]:
        continue

    for next_node, weight in adjList[current_node]:
        new_dist = dist[current_node] + weight
        if new_dist < dist[next_node]:
            dist[next_node] = new_dist
            heapq.heappush(pq, (new_dist, next_node))

for i in range(1, v + 1):
    if dist[i] == float("inf"):
        print("INF")
    else:
        print(dist[i])`,
                    javascript: `class PriorityQueue {
    constructor(comparator = (a, b) => a - b) {
        this.heap = [];
        this.comparator = comparator;
    }
    size() { return this.heap.length; }
    isEmpty() { return this.heap.length === 0; }
    peek() { return this.heap[0]; }
    push(value) {
        this.heap.push(value);
        this.bubbleUp();
    }
    pop() {
        if (this.isEmpty()) return undefined;
        if (this.heap.length === 1) return this.heap.pop();
        const value = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown();
        return value;
    }
    bubbleUp() {
        let index = this.heap.length - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.comparator(this.heap[index], this.heap[parentIndex]) < 0) {
                [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
                index = parentIndex;
            } else { break; }
        }
    }
    bubbleDown() {
        let index = 0;
        while (true) {
            let leftChildIndex = 2 * index + 1;
            let rightChildIndex = 2 * index + 2;
            let smallestChildIndex = index;
            if (leftChildIndex < this.heap.length && this.comparator(this.heap[leftChildIndex], this.heap[smallestChildIndex]) < 0) {
                smallestChildIndex = leftChildIndex;
            }
            if (rightChildIndex < this.heap.length && this.comparator(this.heap[rightChildIndex], this.heap[smallestChildIndex]) < 0) {
                smallestChildIndex = rightChildIndex;
            }
            if (smallestChildIndex === index) break;
            [this.heap[index], this.heap[smallestChildIndex]] = [this.heap[smallestChildIndex], this.heap[index]];
            index = smallestChildIndex;
        }
    }
}

const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');
let lineIndex = 0;

const [v, e] = input[lineIndex++].split(' ').map(Number);
const k = Number(input[lineIndex++]);

const adjList = Array.from({ length: v + 1 }, () => []);
const dist = new Array(v + 1).fill(Infinity);

for (let i = 0; i < e; i++) {
    const [u, w, weight] = input[lineIndex++].split(' ').map(Number);
    adjList[u].push({ node: w, weight: weight });
}

const pq = new PriorityQueue((a, b) => a.weight - b.weight);
dist[k] = 0;
pq.push({ node: k, weight: 0 });

while (!pq.isEmpty()) {
    const current = pq.pop();

    if (current.weight > dist[current.node]) {
        continue;
    }

    for (const next of adjList[current.node]) {
        const newDist = dist[current.node] + next.weight;
        if (newDist < dist[next.node]) {
            dist[next.node] = newDist;
            pq.push({ node: next.node, weight: newDist });
        }
    }
}

let result = '';
for (let i = 1; i <= v; i++) {
    if (dist[i] === Infinity) {
        result += "INF\\n";
    } else {
        result += dist[i] + "\\n";
    }
}
console.log(result.trim());`
                }
            },
            {
                type: 'problem_detail',
                title: '문제 7: K번째 최단 경로 (BOJ 1854)',
                problem: '1번 도시에서 N번 도시로 가는 K번째 최단경로를 구하는 프로그램을 작성하시오. 도로는 단방향이다.',
                input: '첫째 줄에 도시의 수 N (1 ≤ N ≤ 1,000), 도로의 수 M (0 ≤ M ≤ 2,000,000), 그리고 K (1 ≤ K ≤ 100)가 주어진다. 도시의 번호는 1번부터 N번까지이다. 둘째 줄부터 M개의 줄에 걸쳐 도로의 정보 a, b, c가 주어진다. 이는 a번 도시에서 b번 도시로 가는 데 시간이 c (1 ≤ c ≤ 1,000) 걸린다는 의미이다.',
                output: '1번 도시부터 N번 도시 각각까지의 K번째 최단경로를 한 줄에 하나씩 출력한다. 만약 K번째 최단경로가 존재하지 않으면 -1을 출력한다.',
                example_input_1: `5 10 2
1 2 2
1 3 7
1 4 5
1 5 6
2 4 2
2 5 8
3 4 4
3 5 3
4 5 1
5 1 4`,
                example_output_1: `-1
2
7
4
7`
            },
            {
                type: 'problem',
                title: '알고리즘: 다익스트라 변형',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class bj7_1854 {

    static class Node implements Comparable<Node> {
        int node;
        int weight;

        Node(int node, int weight) {
            this.node = node;
            this.weight = weight;
        }

        @Override
        public int compareTo(Node o) {
            return this.weight - o.weight;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        ArrayList<Node>[] adjList = new ArrayList[n + 1];
        PriorityQueue<Integer>[] distPQs = new PriorityQueue[n + 1];

        for (int i = 1; i <= n; i++) {
            adjList[i] = new ArrayList<>();
            distPQs[i] = new PriorityQueue<>(Collections.reverseOrder());
        }

        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            adjList[a].add(new Node(b, c));
        }

        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(1, 0));
        distPQs[1].add(0);

        while (!pq.isEmpty()) {
            Node current = pq.poll();

            for (Node next : adjList[current.node]) {
                int newDist = current.weight + next.weight;

                if (distPQs[next.node].size() < k) {
                    distPQs[next.node].add(newDist);
                    pq.add(new Node(next.node, newDist));
                }
                else if (newDist < distPQs[next.node].peek()) {
                    distPQs[next.node].poll();
                    distPQs[next.node].add(newDist);
                    pq.add(new Node(next.node, newDist));
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= n; i++) {
            if (distPQs[i].size() < k) {
                sb.append("-1\\n");
            } else {
                sb.append(distPQs[i].peek()).append("\\n");
            }
        }
        System.out.print(sb);
    }
}`,
                    python: `import sys
import heapq

input = sys.stdin.readline
n, m, k = map(int, input().split())

adjList = [[] for _ in range(n + 1)]
distPQs = [[] for _ in range(n + 1)]

for _ in range(m):
    a, b, c = map(int, input().split())
    adjList[a].append((b, c))

pq = []
heapq.heappush(pq, (0, 1))
heapq.heappush(distPQs[1], 0)

while pq:
    current_weight, current_node = heapq.heappop(pq)

    for next_node, weight in adjList[current_node]:
        new_dist = current_weight + weight

        if len(distPQs[next_node]) < k:
            heapq.heappush(distPQs[next_node], -new_dist)
            heapq.heappush(pq, (new_dist, next_node))
        elif new_dist < -distPQs[next_node][0]:
            heapq.heappop(distPQs[next_node])
            heapq.heappush(distPQs[next_node], -new_dist)
            heapq.heappush(pq, (new_dist, next_node))

for i in range(1, n + 1):
    if len(distPQs[i]) < k:
        print("-1")
    else:
        print(-distPQs[i][0])`,
                    javascript: `class PriorityQueue {
    constructor(comparator = (a, b) => a - b) {
        this.heap = []; this.comparator = comparator;
    }
    size() { return this.heap.length; }
    isEmpty() { return this.heap.length === 0; }
    peek() { return this.heap[0]; }
    push(value) { this.heap.push(value); this.bubbleUp(); }
    pop() {
        if (this.isEmpty()) return undefined; if (this.heap.length === 1) return this.heap.pop();
        const value = this.heap[0]; this.heap[0] = this.heap.pop(); this.bubbleDown(); return value;
    }
    bubbleUp() {
        let i = this.heap.length - 1;
        while (i > 0) {
            const p = Math.floor((i - 1) / 2);
            if (this.comparator(this.heap[i], this.heap[p]) < 0) { [this.heap[i], this.heap[p]] = [this.heap[p], this.heap[i]]; i = p; }
            else break;
        }
    }
    bubbleDown() {
        let i = 0;
        while (true) {
            let l = 2*i + 1, r = 2*i + 2, s = i;
            if (l < this.heap.length && this.comparator(this.heap[l], this.heap[s]) < 0) s = l;
            if (r < this.heap.length && this.comparator(this.heap[r], this.heap[s]) < 0) s = r;
            if (s === i) break; [this.heap[i], this.heap[s]] = [this.heap[s], this.heap[i]]; i = s;
        }
    }
}

const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');
let lineIndex = 0;

const [n, m, k] = input[lineIndex++].split(' ').map(Number);

const adjList = Array.from({ length: n + 1 }, () => []);
const distPQs = Array.from({ length: n + 1 }, () => new PriorityQueue((a, b) => b - a));

for (let i = 0; i < m; i++) {
    const [a, b, c] = input[lineIndex++].split(' ').map(Number);
    adjList[a].push({ node: b, weight: c });
}

const pq = new PriorityQueue((a, b) => a.weight - b.weight);
pq.push({ node: 1, weight: 0 });
distPQs[1].push(0);

while (!pq.isEmpty()) {
    const current = pq.pop();

    for (const next of adjList[current.node]) {
        const newDist = current.weight + next.weight;

        if (distPQs[next.node].size() < k) {
            distPQs[next.node].push(newDist);
            pq.push({ node: next.node, weight: newDist });
        } else if (newDist < distPQs[next.node].peek()) {
            distPQs[next.node].pop();
            distPQs[next.node].push(newDist);
            pq.push({ node: next.node, weight: newDist });
        }
    }
}

let resultOutput = '';
for (let i = 1; i <= n; i++) {
    if (distPQs[i].size() < k) {
        resultOutput += "-1\\n";
    } else {
        resultOutput += distPQs[i].peek() + "\\n";
    }
}
console.log(resultOutput.trim());`
                }
            }
        ];

        let presentationData = presentationData_part1.concat(presentationData_part2);

        const presentationContainer = document.getElementById('presentation-container');
        let currentSlide = 0;
        let currentLang = 0;

        function prevModalStep() {
            if (currentExplanationStep > 0) {
                currentExplanationStep--;
                renderModalStep();
                modalContent.scrollTop = 0;
            }
        }

        function nextModalStep() {
            if (currentExplanationStep < totalExplanationSteps - 1) {
                currentExplanationStep++;
                renderModalStep();
                modalContent.scrollTop = 0;
            }
        }

        function closeModal() {
            modalBackdrop.style.display = 'none';
            modalContent.style.display = 'none';
            explanationContainer.innerHTML = '';
            document.body.style.overflow = '';
            currentExplanationData = null;
            currentExplanationStep = 0;
            totalExplanationSteps = 0;
        }

        modalCloseBtn.addEventListener('click', closeModal);
        modalBackdrop.addEventListener('click', closeModal);

        function renderSlides() {
            presentationContainer.innerHTML = '';
            presentationData.forEach((data, index) => {
                let slideHtml = '';

                if (data.type === 'title') {
                    slideHtml = `<div class="slide flex-col items-center justify-center p-8 text-center" data-slide-index="${index}">
                        <h1 class="text-8xl md:text-9xl font-bold text-gray-800 mb-16">${data.title}</h1>
                        <div class="mt-8 text-4xl md:text-5xl text-gray-600">
                           <p>${data.author}</p>
                           <p class="mt-2 font-semibold text-gray-700">${data.author_detail}</p>
                        </div>
                    </div>`;
                } else if (data.type === 'toc') {
                    slideHtml = `<div class="slide flex-col items-center justify-center p-8" data-slide-index="${index}">
                        <h2 class="text-7xl md:text-8xl font-bold mb-16 text-gray-800">${data.title}</h2>
                        <ul class="grid grid-cols-1 md:grid-cols-2 gap-x-24 gap-y-10 text-4xl md:text-5xl text-gray-700">
                            ${data.items.map((item, i) => `<li class="toc-item flex items-center" data-goto-slide="${(i * 2) + 2}"><span class="text-gray-500 font-bold mr-6">${i + 1}.</span>${item}</li>`).join('')}
                        </ul></div>`;
                } else if (data.type === 'problem_detail') {
                    const detailButtonHtml = data.problemId ? `
                        <div class="absolute top-8 right-12 z-10">
                            <button onclick="openModal('${data.problemId}')" class="bg-sky-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-sky-700 transition-colors shadow-md text-2xl">
                                자세히 보기
                            </button>
                        </div>
                    ` : '';
                    slideHtml = `
                        <div class="slide flex-col p-8 md:p-12 bg-gray-50 relative" data-slide-index="${index}">
                             ${detailButtonHtml}
                            <h2 class="text-5xl md:text-6xl font-bold mb-8 text-gray-800 self-start">${data.title}</h2>
                            <div class="w-full flex-1 grid grid-cols-1 lg:grid-cols-5 gap-6 overflow-hidden">
                                <div class="lg:col-span-3 bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col">
                                    <h3 class="text-3xl font-semibold text-sky-700 mb-4 flex-shrink-0">문제 설명</h3>
                                    <div class="overflow-auto problem-detail-box flex-1">
                                      <p class="text-2xl text-gray-700 leading-relaxed whitespace-pre-line">${data.problem}</p>
                                    </div>
                                </div>
                                <div class="lg:col-span-2 flex flex-col gap-6">
                                    <div class="flex-1 bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col">
                                        <h3 class="text-3xl font-semibold text-sky-700 mb-4 flex-shrink-0">입출력 형식</h3>
                                        <div class="grid grid-cols-1 gap-4 overflow-auto problem-detail-box flex-1">
                                            <div>
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">입력</h4>
                                                <p class="text-xl text-gray-600 leading-relaxed whitespace-pre-line">${data.input}</p>
                                            </div>
                                            <hr class="my-2 border-gray-200">
                                            <div>
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">출력</h4>
                                                <p class="text-xl text-gray-600 leading-relaxed whitespace-pre-line">${data.output}</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex-1 bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col">
                                        <h3 class="text-3xl font-semibold text-sky-700 mb-4 flex-shrink-0">예제</h3>
                                        <div class="grid grid-cols-2 gap-4 flex-1 overflow-hidden">
                                            <div class="example-box">
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">입력</h4>
                                                <pre class="text-xl">${data.example_input_1 || ''}</pre>
                                            </div>
                                            <div class="example-box">
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">출력</h4>
                                                <pre class="text-xl">${data.example_output_1 || ''}</pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>`;

                } else if (data.type === 'problem') {
                    const languages = ['java', 'python', 'javascript'];
                    let codeBlocksHtml = '';

                    languages.forEach(lang => {
                        const codeString = data.codes[lang] || '';
                        const langSpecificCode = codeString.replace(/\\n/g, '\n');

                        const innerHtml = `
                            <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-lg p-4 text-2xl h-full overflow-auto">
                                <pre><code class="language-${lang}">${langSpecificCode.trim()}</code></pre>
                            </div>`;

                        codeBlocksHtml += `<div class="code-container h-full" data-lang="${lang}">${innerHtml}</div>`;
                    });

                    slideHtml = `
                        <div class="slide flex-col p-8 md:p-12" data-slide-index="${index}" data-is-problem="true">
                            <div class="flex-shrink-0">
                                <h2 class="text-6xl md:text-7xl font-bold mb-4 text-gray-800">${data.title}</h2>
                            </div>
                            <div class="flex-1 mt-4 flex flex-col min-h-0">
                                <div class="flex items-center justify-center space-x-6 mb-4">
                                    <span class="lang-indicator java text-4xl font-bold p-2 cursor-pointer">Java</span>
                                    <span class="lang-indicator python text-4xl font-bold p-2 cursor-pointer">Python</span>
                                    <span class="lang-indicator javascript text-4xl font-bold p-2 cursor-pointer">JavaScript</span>
                                </div>
                                <div class="flex-1 relative min-h-0">${codeBlocksHtml}</div>
                            </div>
                        </div>`;
                }
                presentationContainer.insertAdjacentHTML('beforeend', slideHtml);
            });

            document.querySelectorAll('pre code').forEach(block => {
                block.innerHTML = block.innerHTML.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                hljs.highlightElement(block);
            });

            document.querySelectorAll('.toc-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const slideIndex = parseInt(e.currentTarget.dataset.gotoSlide, 10);
                    if (!isNaN(slideIndex)) {
                        currentSlide = slideIndex;
                        currentLang = 0;
                        updateSlideState();
                    }
                });
            });
        }

        function updateSlideState() {
            const slides = document.querySelectorAll('.slide');
            slides.forEach((slide, index) => slide.classList.toggle('active', index === currentSlide));

            const activeSlide = slides[currentSlide];
            if (activeSlide && activeSlide.dataset.isProblem) {
                const languages = ['java', 'python', 'javascript'];
                const currentLangName = languages[currentLang];

                activeSlide.querySelectorAll('.lang-indicator').forEach((indicator, index) => {
                    const isActive = index === currentLang;
                    indicator.classList.toggle('text-sky-600', isActive);
                    indicator.classList.toggle('text-gray-300', !isActive);
                    indicator.style.transform = isActive ? 'scale(1.15)' : 'scale(1.0)';
                    indicator.onclick = () => {
                        currentLang = index;
                        updateSlideState();
                    };
                });

                activeSlide.querySelectorAll('.code-container').forEach(container => {
                    const isActive = container.dataset.lang === currentLangName;
                    container.classList.toggle('visible', isActive);
                });
            }
        }

        const goNext = () => {
            const activeSlide = document.querySelector('.slide.active');
            if (!activeSlide) return;

            if (activeSlide.dataset.isProblem && currentLang < 2) {
                currentLang++;
            } else {
                if (currentSlide < presentationData.length - 1) {
                    currentSlide++;
                    currentLang = 0;
                }
            }
            updateSlideState();
        };

        const goPrev = () => {
            const activeSlide = document.querySelector('.slide.active');
            if (!activeSlide) return;

            if (activeSlide.dataset.isProblem && currentLang > 0) {
                currentLang--;
            } else {
                if (currentSlide > 0) {
                    currentSlide--;
                    const prevSlide = document.querySelector(`[data-slide-index="${currentSlide}"]`);
                    currentLang = prevSlide.dataset.isProblem ? 2 : 0;
                }
            }
            updateSlideState();
        };

        document.addEventListener('DOMContentLoaded', () => {
            renderSlides();
            updateSlideState();

            document.addEventListener('keydown', e => {
                if (modalBackdrop.style.display !== 'block') {
                    if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') goNext();
                    if (e.key === 'ArrowLeft' || e.key === 'PageUp') goPrev();
                } else {
                    if (e.key === 'ArrowLeft') prevModalStep();
                    if (e.key === 'ArrowRight') nextModalStep();
                    if (e.key === 'Escape') closeModal();
                }
            });
        });
    </script>
</body>

</html>