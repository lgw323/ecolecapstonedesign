<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>알고리즘 10문제: Java, Python, JS 풀이 분석 (WEEK3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        /* 상세 설명 모달을 위한 스타일 */
        #modal-backdrop {
            display: none;
            /* 기본적으로 숨김 */
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 40;
        }

        #modal-content {
            display: none;
            /* 기본적으로 숨김 */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            height: 90vh;
            background-color: #f9fafb;
            /* bg-gray-50 */
            z-index: 50;
            overflow-y: auto;
        }
    </style>
</head>

<body class="bg-white text-black">

    <!-- 메인 프레젠테이션 컨테이너 -->
    <div id="presentation-root" class="relative w-screen h-screen">
        <div id="presentation-container" class="w-full h-full bg-white flex flex-col overflow-hidden">
        </div>
    </div>

    <!-- 상세 설명을 위한 모달 UI -->
    <div id="modal-backdrop"></div>
    <div id="modal-content" class="p-4 sm:p-6 lg:p-8 rounded-2xl shadow-2xl">
        <button id="modal-close-btn"
            class="absolute top-4 right-6 text-5xl font-bold text-gray-500 hover:text-gray-800">&times;</button>
        <div id="explanation-container" class="max-w-7xl mx-auto">
            <!-- 동적 콘텐츠가 여기에 삽입됩니다. -->
        </div>
    </div>


    <script>
        // --- 데이터 시작 ---

        // 메인 슬라이드 데이터
        const presentationData = [
            // --- 표지 & 목차 ---
            {
                type: 'title',
                title: '알고리즘 10문제 (3주차)',
                author: '경성대학교 소프트웨어학과',
                author_detail: '2021663046 이건우'
            },
            {
                type: 'toc',
                title: '발표 순서 (3주차)',
                items: [
                    '수 찾기 (BOJ 1920)', '기타 레슨 (BOJ 2343)', '동전 0 (BOJ 11047)',
                    '카드 정렬하기 (BOJ 1715)', '회의실 배정 (BOJ 1931)', '잃어버린 괄호 (BOJ 1541)',
                    '소수 구하기 (BOJ 1929)', 'GCD(n, k) = 1 (BOJ 11689)', '최소공배수 (BOJ 1934)',
                    'Ax + By = C (BOJ 21568)'
                ]
            },
            // --- 문제 1: 이진 탐색 ---
            {
                type: 'problem_detail',
                title: '문제 1: 수 찾기 (BOJ 1920)',
                problem: 'N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.',
                input: '첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내야 한다. 모든 정수의 범위는 -2^31 보다 크거나 같고 2^31보다 작다.',
                output: 'M개의 줄에 답을 출력한다. 존재하면 1, 존재하지 않으면 0을 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 이진 탐색',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class bj1_1920 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        Arrays.sort(arr);

        int m = Integer.parseInt(br.readLine());
        st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < m; i++) {
            int target = Integer.parseInt(st.nextToken());
            if (binarySearch(arr, target)) {
                sb.append(1).append("\\n");
            } else {
                sb.append(0).append("\\n");
            }
        }
        System.out.print(sb);
    }
    
    private static boolean binarySearch(int[] arr, int target) {
        int start = 0;
        int end = arr.length - 1;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (arr[mid] == target) return true;
            if (arr[mid] < target) start = mid + 1;
            else end = mid - 1;
        }
        return false;
    }
}`,
                    python: `import sys

def binary_search(arr, target):
    start, end = 0, len(arr) - 1
    while start <= end:
        mid = (start + end) // 2
        if arr[mid] == target:
            return 1
        elif arr[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return 0

n = int(sys.stdin.readline())
arr_n = sorted(list(map(int, sys.stdin.readline().split())))
m = int(sys.stdin.readline())
arr_m = list(map(int, sys.stdin.readline().split()))

for target in arr_m:
    print(binary_search(arr_n, target))`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const n = parseInt(input[0]);
const arrN = input[1].split(' ').map(Number).sort((a, b) => a - b);
const m = parseInt(input[2]);
const arrM = input[3].split(' ').map(Number);

function binarySearch(arr, target) {
    let start = 0;
    let end = arr.length - 1;
    while (start <= end) {
        let mid = Math.floor((start + end) / 2);
        if (arr[mid] === target) return 1;
        if (arr[mid] < target) start = mid + 1;
        else end = mid - 1;
    }
    return 0;
}

const result = arrM.map(target => binarySearch(arrN, target));
console.log(result.join('\\n'));`
                }
            },
            // --- 문제 2: 파라메트릭 서치 ---
            {
                type: 'problem_detail',
                title: '문제 2: 기타 레슨 (BOJ 2343)',
                problem: '강토는 자신의 기타 강의를 블루레이로 만들어 판매하려고 한다. 블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. 순서가 뒤바뀌는 경우에는 강의의 흐름이 끊겨, 학생들이 혼란에 빠질 수 있기 때문이다. 즉, i번 강의와 j번 강의를 같은 블루레이에 녹화하려면 i와 j 사이의 모든 강의도 같은 블루레이에 녹화해야 한다. 또한 M개의 블루레이를 모두 사용하지 않아도 된다. 이때, 블루레이의 크기(녹화 가능한 길이)를 최소로 하려고 한다.',
                input: '첫째 줄에 강의의 수 N (1 ≤ N ≤ 100,000)과 M (1 ≤ M ≤ N)이 주어진다. 다음 줄에는 강토의 기타 강의의 길이가 N개 주어진다. 강의의 길이는 10,000분을 넘지 않는 자연수이다.',
                output: '첫째 줄에 가능한 블루레이 크기중 최소를 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 파라메트릭 서치',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj2_2343 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        int[] lectures = new int[n];
        st = new StringTokenizer(br.readLine());
        long sum = 0;
        int maxLecture = 0;
        for (int i = 0; i < n; i++) {
            lectures[i] = Integer.parseInt(st.nextToken());
            sum += lectures[i];
            if (lectures[i] > maxLecture) maxLecture = lectures[i];
        }

        long left = maxLecture, right = sum;
        while (left <= right) {
            long mid = (left + right) / 2;
            int count = 1;
            long currentSum = 0;
            for (int lecture : lectures) {
                if (currentSum + lecture > mid) {
                    count++;
                    currentSum = lecture;
                } else {
                    currentSum += lecture;
                }
            }
            if (count <= m) right = mid - 1;
            else left = mid + 1;
        }
        System.out.println(left);
    }
}`,
                    python: `import sys

n, m = map(int, sys.stdin.readline().split())
lectures = list(map(int, sys.stdin.readline().split()))

left, right = max(lectures), sum(lectures)
result = right

while left <= right) {
    mid = (left + right) // 2
    count = 1
    current_sum = 0
    for lecture in lectures:
        if current_sum + lecture > mid:
            count += 1
            current_sum = lecture
        else:
            current_sum += lecture
    
    if count <= m:
        result = mid
        right = mid - 1
    else:
        left = mid + 1

print(result)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const [n, m] = input[0].split(' ').map(Number);
const lectures = input[1].split(' ').map(Number);

let left = Math.max(...lectures);
let right = lectures.reduce((a, b) => a + b, 0);
let result = right;

while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    let count = 1;
    let currentSum = 0;
    for (const lecture of lectures) {
        if (currentSum + lecture > mid) {
            count++;
            currentSum = lecture;
        } else {
            currentSum += lecture;
        }
    }

    if (count <= m) {
        result = mid;
        right = mid - 1;
    } else {
        left = mid + 1;
    }
}

console.log(result);`
                }
            },
            // --- 문제 3: 그리디 ---
            {
                type: 'problem_detail',
                title: '문제 3: 동전 0 (BOJ 11047)',
                problem: '준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000) 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)',
                output: '첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj3_11047 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        int[] coins = new int[n];
        for (int i = 0; i < n; i++) {
            coins[i] = Integer.parseInt(br.readLine());
        }

        int count = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (coins[i] <= k) {
                count += (k / coins[i]);
                k %= coins[i];
            }
        }
        System.out.println(count);
    }
}`,
                    python: `import sys

n, k = map(int, sys.stdin.readline().split())
coins = [int(sys.stdin.readline()) for _ in range(n)]

count = 0
for i in range(n - 1, -1, -1):
    if coins[i] <= k:
        count += k // coins[i]
        k %= coins[i]

print(count)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

let [n, k] = input[0].split(' ').map(Number);
const coins = [];
for (let i = 1; i <= n; i++) {
    coins.push(Number(input[i]));
}

let count = 0;
for (let i = n - 1; i >= 0; i--) {
    if (coins[i] <= k) {
        count += Math.floor(k / coins[i]);
        k %= coins[i];
    }
    if (k === 0) break;
}

console.log(count);`
                }
            },
            // --- 문제 4: 우선순위 큐 ---
            {
                type: 'problem_detail',
                title: '문제 4: 카드 정렬하기 (BOJ 1715)',
                problem: '정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.',
                output: '첫째 줄에 최소 비교 횟수를 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디 (우선순위 큐)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;

public class bj4_1715 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        PriorityQueue<Long> pq = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            pq.add(Long.parseLong(br.readLine()));
        }

        long sum = 0;
        while (pq.size() > 1) {
            long temp1 = pq.poll();
            long temp2 = pq.poll();

            sum += temp1 + temp2;
            pq.add(temp1 + temp2);
        }

        System.out.println(sum);
    }
}`,
                    python: `import sys
import heapq

n = int(sys.stdin.readline())
cards = []
for _ in range(n):
    heapq.heappush(cards, int(sys.stdin.readline()))

total_sum = 0
while len(cards) > 1:
    temp1 = heapq.heappop(cards)
    temp2 = heapq.heappop(cards)

    current_sum = temp1 + temp2
    total_sum += current_sum
    heapq.heappush(cards, current_sum)

print(total_sum)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n').map(Number);
const n = input[0];
const cards = input.slice(1);

class MinHeap {
    constructor() { this.heap = []; }
    size() { return this.heap.length; }
    push(v) { this.heap.push(v); this.bubbleUp(); }
    pop() {
        const val = this.heap[0];
        this.heap[0] = this.heap.pop();
        if (this.size() > 0) this.bubbleDown();
        return val;
    }
    bubbleUp() {
        let i = this.size() - 1;
        while (i > 0) {
            const p = Math.floor((i - 1) / 2);
            if (this.heap[p] <= this.heap[i]) break;
            [this.heap[p], this.heap[i]] = [this.heap[i], this.heap[p]];
            i = p;
        }
    }
    bubbleDown() {
        let i = 0;
        while (true) {
            let l = 2*i + 1, r = 2*i + 2, s = i;
            if (l < this.size() && this.heap[l] < this.heap[s]) s = l;
            if (r < this.size() && this.heap[r] < this.heap[s]) s = r;
            if (s === i) break;
            [this.heap[s], this.heap[i]] = [this.heap[i], this.heap[s]];
            i = s;
        }
    }
}

const pq = new MinHeap();
for (const card of cards) pq.push(card);
let totalSum = 0;
while (pq.size() > 1) {
    const s = pq.pop() + pq.pop();
    totalSum += s;
    pq.push(s);
}
console.log(totalSum);`
                }
            },
            // --- 문제 5: 그리디 ---
            {
                type: 'problem_detail',
                title: '문제 5: 회의실 배정 (BOJ 1931)',
                problem: '한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.',
                input: '첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2^31-1보다 작거나 같은 자연수 또는 0이다.',
                output: '첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디 (정렬)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class bj5_1931 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[][] meetings = new int[n][2];

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            meetings[i][0] = Integer.parseInt(st.nextToken());
            meetings[i][1] = Integer.parseInt(st.nextToken());
        }

        Arrays.sort(meetings, (o1, o2) -> {
            if (o1[1] == o2[1]) {
                return o1[0] - o2[0];
            }
            return o1[1] - o2[1];
        });

        int count = 0;
        int endTime = 0;
        for (int i = 0; i < n; i++) {
            if (meetings[i][0] >= endTime) {
                endTime = meetings[i][1];
                count++;
            }
        }
        System.out.println(count);
    }
}`,
                    python: `import sys

n = int(sys.stdin.readline())
meetings = []
for _ in range(n):
    start, end = map(int, sys.stdin.readline().split())
    meetings.append((start, end))

meetings.sort(key=lambda x: (x[1], x[0]))

count = 0
end_time = 0
for meeting in meetings:
    if meeting[0] >= end_time:
        end_time = meeting[1]
        count += 1

print(count)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const n = Number(input[0]);
const meetings = [];
for (let i = 1; i <= n; i++) {
    meetings.push(input[i].split(' ').map(Number));
}

meetings.sort((a, b) => {
    if (a[1] === b[1]) {
        return a[0] - b[0];
    }
    return a[1] - b[1];
});

let count = 0;
let endTime = 0;
for (const meeting of meetings) {
    if (meeting[0] >= endTime) {
        endTime = meeting[1];
        count++;
    }
}

console.log(count);`
                }
            },
            // --- 문제 6: 그리디 ---
            {
                type: 'problem_detail',
                title: '문제 6: 잃어버린 괄호 (BOJ 1541)',
                problem: '세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다. 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.',
                input: '첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 식의 길이는 50보다 작거나 같다.',
                output: '첫째 줄에 정답을 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디 (문자열 처리)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class bj6_1541 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] subtraction = br.readLine().split("-");
        int result = 0;

        for (int i = 0; i < subtraction.length; i++) {
            int tempSum = 0;
            String[] addition = subtraction[i].split("\\\\+");
            for (String s : addition) {
                tempSum += Integer.parseInt(s);
            }

            if (i == 0) {
                result += tempSum;
            } else {
                result -= tempSum;
            }
        }
        System.out.println(result);
    }
}`,
                    python: `import sys

expression = sys.stdin.readline().strip().split("-")
result = 0

first_part = list(map(int, expression[0].split("+")))
result += sum(first_part)

for i in range(1, len(expression)):
    other_part = list(map(int, expression[i].split("+")))
    result -= sum(other_part)

print(result)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim();

const parts = input.split('-');
let result = 0;

const firstPartSum = parts[0].split('+').map(Number).reduce((a, b) => a + b, 0);
result += firstPartSum;

for (let i = 1; i < parts.length; i++) {
    const otherPartSum = parts[i].split('+').map(Number).reduce((a, b) => a + b, 0);
    result -= otherPartSum;
}

console.log(result);`
                }
            },
            // --- 문제 7: 소수 ---
            {
                type: 'problem_detail',
                title: '문제 7: 소수 구하기 (BOJ 1929)',
                problem: 'M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.',
                input: '첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M과 N사이의 소수가 하나 이상 있는 입력만 주어진다.',
                output: '한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 에라토스테네스의 체',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj7_1929 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int m = Integer.parseInt(st.nextToken());
        int n = Integer.parseInt(st.nextToken());

        boolean[] isPrime = new boolean[n + 1];
        for (int i = 2; i <= n; i++) isPrime[i] = true;

        for (int i = 2; i * i <= n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = m; i <= n; i++) {
            if (isPrime[i]) sb.append(i).append('\\n');
        }
        System.out.print(sb);
    }
}`,
                    python: `import sys
import math

m, n = map(int, sys.stdin.readline().split())

is_prime = [True] * (n + 1)
if n >= 0:
    if len(is_prime) > 0: is_prime[0] = False
    if len(is_prime) > 1: is_prime[1] = False

for i in range(2, int(math.sqrt(n)) + 1):
    if is_prime[i]:
        for j in range(i * i, n + 1, i):
            is_prime[j] = False

for i in range(m, n + 1):
    if is_prime[i]:
        print(i)`,
                    javascript: `const fs = require('fs');
const [m, n] = fs.readFileSync('/dev/stdin').toString().trim().split(' ').map(Number);

const isPrime = new Array(n + 1).fill(true);
isPrime[0] = false;
isPrime[1] = false;

for (let i = 2; i * i <= n; i++) {
    if (isPrime[i]) {
        for (let j = i * i; j <= n; j += i) {
            isPrime[j] = false;
        }
    }
}

const result = [];
for (let i = m; i <= n; i++) {
    if (isPrime[i]) result.push(i);
}
console.log(result.join('\\n'));`
                }
            },
            // --- 문제 8: 오일러 피 ---
            {
                type: 'problem_detail',
                title: '문제 8: GCD(n, k) = 1 (BOJ 11689)',
                problem: '자연수 n이 주어졌을 때, GCD(n, k) = 1을 만족하는 자연수 1 ≤ k ≤ n의 개수를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 자연수 n (1 ≤ n ≤ 10^12)이 주어진다.',
                output: 'GCD(n, k) = 1을 만족하는 자연수 1 ≤ k ≤ n의 개수를 출력한다.',
                problemId: 'bj11689' // 각 문제에 대한 고유 ID 추가
            },
            {
                type: 'problem',
                title: '알고리즘: 오일러 피 함수',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class bj8_11689 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine());
        long phi = n;

        for (long p = 2; p * p <= n; p++) {
            if (n % p == 0) {
                phi = phi / p * (p - 1);
                while (n % p == 0) {
                    n /= p;
                }
            }
        }

        if (n > 1) {
            phi = phi / n * (n - 1);
        }

        System.out.println(phi);
    }
}`,
                    python: `import sys

n = int(sys.stdin.readline())
phi = n
p = 2
while p * p <= n:
    if n % p == 0:
        phi = phi // p * (p - 1)
        while n % p == 0:
            n //= p
    p += 1

if n > 1:
    phi = phi // n * (n - 1)

print(phi)`,
                    javascript: `const fs = require('fs');
let n = BigInt(fs.readFileSync('/dev/stdin').toString().trim());

let phi = n;
for (let p = 2n; p * p <= n; p++) {
    if (n % p === 0n) {
        phi = phi / p * (p - 1n);
        while (n % p === 0n) {
            n /= p;
        }
    }
}

if (n > 1n) {
    phi = phi / n * (n - 1n);
}

console.log(phi.toString());`
                }
            },
            // --- 문제 9: 최소공배수 ---
            {
                type: 'problem_detail',
                title: '문제 9: 최소공배수 (BOJ 1934)',
                problem: '두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)',
                output: '첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 각각 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 유클리드 호제법',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj9_1934 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < t; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            long result = (long) a * b / gcd(a, b);
            sb.append(result).append('\\n');
        }
        System.out.print(sb);
    }

    private static int gcd(int a, int b) {
        while (b != 0) {
            int r = a % b;
            a = b;
            b = r;
        }
        return a;
    }
}`,
                    python: `import sys
import math

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return (a * b) // gcd(a, b)

t = int(sys.stdin.readline())
for _ in range(t):
    a, b = map(int, sys.stdin.readline().split())
    print(lcm(a, b))`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const t = Number(input[0]);

function gcd(a, b) {
    while (b) { [a, b] = [b, a % b]; }
    return a;
}

function lcm(a, b) {
    return (a * b) / gcd(a, b);
}

let result = '';
for (let i = 1; i <= t; i++) {
    const [a, b] = input[i].split(' ').map(Number);
    result += lcm(a, b) + '\\n';
}

console.log(result.trim());`
                }
            },
            // --- 문제 10: 확장 유클리드 ---
            {
                type: 'problem_detail',
                title: '문제 10: Ax + By = C (BOJ 21568)',
                problem: '정수 a, b, c가 주어졌을 때, ax + by = c를 만족하는 정수 x, y를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 세 정수 a, b, c가 주어진다. (1 ≤ a, b, c ≤ 1,000,000,000) 문제의 답이 항상 존재하는 경우만 입력으로 주어진다.',
                output: 'ax + by = c를 만족하는 정수 x, y를 순서대로 공백으로 구분해 출력한다. 답이 여러 개인 경우 아무거나 하나 출력한다.'
            },
            {
                type: 'problem',
                title: '알고리즘: 확장 유클리드 호제법',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj10_21568 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        long a = Long.parseLong(st.nextToken());
        long b = Long.parseLong(st.nextToken());
        long c = Long.parseLong(st.nextToken());

        long[] result = extendedGcd(a, b);
        long gcd = result[0];
        long x0 = result[1];
        
        if (c % gcd != 0) {
             // 답이 항상 존재하는 경우만 입력으로 주어짐
        } else {
            long k = c / gcd;
            System.out.println(x0 * k + " " + (c - a * x0 * k) / b);
        }
    }

    private static long[] extendedGcd(long a, long b) {
        if (b == 0) return new long[] { a, 1, 0 };
        long[] temp = extendedGcd(b, a % b);
        long gcd = temp[0];
        long x = temp[2];
        long y = temp[1] - (a / b) * temp[2];
        return new long[] { gcd, x, y };
    }
}`,
                    python: `import sys

def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x1, y1 = extended_gcd(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return gcd, x, y

a, b, c = map(int, sys.stdin.readline().split())
gcd_val, x0, y0 = extended_gcd(a, b)

k = c // gcd_val
print(x0 * k, y0 * k)`,
                    javascript: `const fs = require('fs');
const [a, b, c] = fs.readFileSync('/dev/stdin').toString().trim().split(' ').map(BigInt);

function extendedGcd(a, b) {
    if (b === 0n) {
        return [a, 1n, 0n];
    }
    const [gcd, x1, y1] = extendedGcd(b, a % b);
    const x = y1;
    const y = x1 - (a / b) * y1;
    return [gcd, x, y];
}

const [gcd_val, x0, y0] = extendedGcd(a, b);

const k = c / gcd_val;
console.log(\`\${x0 * k} \${y0 * k}\`);`
                }
            }
        ];

        // 상세 설명 데이터
        const explanationData = {
            'bj11689': {
                title: 'BOJ 11689: GCD(n, k) = 1 상세 풀이',
                steps: [
                    {
                        step: 1,
                        icon: '🤔',
                        title: '문제 다시 보기',
                        content: `
                            <p class="text-xl text-gray-700 leading-relaxed">
                                자연수 n이 주어졌을 때, 1부터 n까지의 자연수 k 중에서 <strong>GCD(n, k) = 1</strong>을 만족하는 k의 개수를 찾는 문제입니다.
                            </p>
                            <div class="mt-4 p-4 bg-red-50 border border-red-200 rounded-lg">
                                <h4 class="font-semibold text-red-800">🚨 가장 큰 함정: 시간 초과</h4>
                                <p class="text-gray-600">
                                    입력값 n이 최대 10<sup>12</sup> (1조)입니다. 1부터 n까지 모든 k에 대해 일일이 최대공약수(GCD)를 계산하는 방식으로는 절대 시간 안에 풀 수 없습니다. O(N) 알고리즘조차 불가능하며, 수학적인 접근이 반드시 필요합니다.
                                </p>
                            </div>
                        `
                    },
                    {
                        step: 2,
                        icon: '💡',
                        title: '천재적인 아이디어: 오일러 피 함수',
                        content: `
                            <p class="text-xl text-gray-700 leading-relaxed">
                                이 문제는 '오일러 피 함수(Euler's Totient Function)'의 정의와 정확히 일치합니다. 이 함수의 기호는 <span class="font-serif font-bold text-sky-600">φ(n)</span> 입니다.
                            </p>
                            <div class="mt-4 p-4 bg-sky-50 border border-sky-200 rounded-lg">
                                <h4 class="font-semibold text-sky-800">💡 오일러의 생각 뒤집기</h4>
                                <p class="text-gray-600">
                                    "n과 서로소인 친구들(GCD=1)을 어떻게 세지?" 라는 질문 대신, "<strong>n과 서로소가 아닌 녀석들(GCD≠1)을 전부 쫓아내면 남는 게 친구들 아닐까?</strong>" 라고 접근하는 것입니다.
                                </p>
                            </div>
                            <p class="mt-4 text-xl text-gray-700 leading-relaxed">
                            n과 서로소가 아닌 k는, n의 소인수 중 적어도 하나를 공통으로 가지고 있습니다. 예를 들어 n=12 (소인수: 2, 3)라면, 12와 서로소가 아닌 애들은 모두 2의 배수이거나 3의 배수입니다.
                            </p>
                        `
                    },
                    {
                        step: 3,
                        icon: '🧪',
                        title: '아이디어 실험: 체로 걸러내기 (n=30)',
                        content: `
                            <p class="text-xl text-gray-700 leading-relaxed">
                                n=30 (소인수 2, 3, 5) 일 때, 이 아이디어가 어떻게 작동하는지 봅시다.
                            </p>
                            <ol class="mt-4 space-y-3 list-decimal list-inside text-gray-600">
                                <li><strong>전체 30개에서 시작:</strong> 30개 중 2의 배수가 아닌 것의 비율은 1/2 입니다. <br>
                                    <span class="font-mono text-sky-600">30 * (1/2) = 15개</span>가 남습니다.
                                </li>
                                <li><strong>남은 15개 중에서:</strong> 신기하게도, 남은 숫자들 중에서도 3의 배수가 아닌 것의 비율은 정확히 2/3 입니다.<br>
                                    <span class="font-mono text-sky-600">15 * (2/3) = 10개</span>가 남습니다.
                                </li>
                                <li><strong>다시 남은 10개 중에서:</strong> 이번에도, 5의 배수가 아닌 것의 비율은 정확히 4/5 입니다.<br>
                                    <span class="font-mono text-sky-600">10 * (4/5) = 8개</span>가 최종적으로 남습니다.
                                </li>
                            </ol>
                            <div class="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                                <p class="text-green-800">
                                    이 과정은 마치 고운 가루를 만들기 위해 여러 개의 체로 순서대로 걸러내는 것과 같습니다. 각 소인수가 하나의 '체' 역할을 하는 셈이죠.
                                </p>
                            </div>
                        `
                    },
                    {
                        step: 4,
                        icon: '📜',
                        title: '공식으로 변환하기',
                        content: `
                            <p class="text-xl text-gray-700 leading-relaxed">
                                앞선 '체로 걸러내기' 과정을 하나의 수학 공식으로 정리할 수 있습니다.
                            </p>
                            <div class="my-4 p-4 bg-gray-100 rounded-lg text-center">
                                <p class="text-2xl font-serif text-gray-800">
                                    φ(n) = n × (1 - 1/p₁) × (1 - 1/p₂) × ...
                                </p>
                                <p class="mt-2 text-gray-600">(여기서 p₁, p₂, ... 는 n의 모든 고유한 소인수들입니다.)</p>
                            </div>
                            <p class="text-xl text-gray-700 leading-relaxed">
                                하지만 컴퓨터는 분수 계산을 싫어합니다. 정수 계산으로만 이루어지도록 공식을 살짝 변형해봅시다.
                            </p>
                            <div class="my-4 p-4 bg-indigo-50 border border-indigo-200 rounded-lg text-center">
                                <p class="text-2xl font-serif text-indigo-800">
                                    φ(n) = n × (p₁-1)/p₁ × (p₂-1)/p₂ × ...
                                </p>
                                <p class="mt-2 text-gray-600">이 형태가 바로 우리가 코드에 적용할 최종 공식입니다.</p>
                            </div>
                        `
                    },
                    {
                        step: 5,
                        icon: '💻',
                        title: 'Java 코드로 구현하기',
                        content: `
                            <p class="text-xl text-gray-700 leading-relaxed">
                                이제 최종 공식을 코드로 옮겨보겠습니다. 코드를 보면서 각 부분이 어떤 역할을 하는지 설명하겠습니다.
                            </p>
                        `,
                        code: `// 1. 결과(phi)를 n으로 초기화
long phi = n;

// 2. n의 소인수 p를 찾기 위한 여정
for (long p = 2; p * p <= n; p++) {
    
    // 3. p가 n의 소인수가 맞다면?
    if (n % p == 0) {
        
        // 4. 변환된 공식 적용!
        phi = phi / p * (p - 1);

        // 5. n에서 p를 완전히 제거 (중요!)
        while (n % p == 0) {
            n /= p;
        }
    }
}
// 6. 마지막 남은 소인수 처리
if (n > 1) {
    phi = phi / n * (n - 1);
}`,
                        code_explanation: `
                            <ol class="space-y-4 text-gray-700">
                                <li><strong>1. 결과 변수 초기화:</strong> 최종 결과를 담을 <code>phi</code> 변수를 만들고, 공식의 시작점인 <code>n</code>으로 초기화합니다.</li>
                                <li><strong>2. 효율적인 탐색:</strong> <code>p</code>를 2부터 1씩 증가시키며 <code>n</code>의 소인수를 찾습니다. 1조의 모든 수를 확인할 수 없으니, <code>n</code>의 제곱근까지만 확인하면 모든 소인수를 찾을 수 있다는 수학적 원리를 이용합니다.</li>
                                <li><strong>3. 소인수 발견:</strong> <code>if (n % p == 0)</code>. 만약 <code>p</code>로 <code>n</code>이 나누어 떨어진다면, <code>p</code>는 <code>n</code>의 가장 작은 소인수입니다.</li>
                                <li><strong>4. 공식 적용:</strong> <code>phi = phi / p * (p - 1)</code>. 이것이 바로 <code>φ(n) = φ(n) × (p-1)/p</code> 공식을 코드로 옮긴 것입니다. 나눗셈을 먼저 해서 오버플로우를 방지합니다.</li>
                                <li><strong>5. 소인수 제거 (while문):</strong> 이 코드가 가장 중요합니다. 찾은 소인수 <code>p</code>를 <code>n</code>에서 완전히 제거합니다. 예를 들어 <code>n=12</code>일 때 <code>p=2</code>를 찾았다면, 12를 2로 계속 나눠 3으로 만들어 버립니다. 이렇게 해야 나중에 <code>p=4</code>일 때 또다시 계산하는 실수를 막을 수 있습니다.</li>
                                <li><strong>6. 마지막 처리:</strong> 루프가 끝났을 때 <code>n</code>이 1보다 크다면, 그 자체가 마지막 소인수라는 의미입니다. (예: n=998244353). 이 남은 소인수에 대해서도 공식을 한 번 더 적용해줍니다.</li>
                            </ol>
                        `
                    }
                ]
            }
        };

        // --- 메인 스크립트 로직 ---

        const presentationContainer = document.getElementById('presentation-container');
        let currentSlide = 0;
        let currentLang = 0; // 0: Java, 1: Python, 2: JS

        function renderSlides() {
            presentationContainer.innerHTML = '';
            presentationData.forEach((data, index) => {
                let slideHtml = '';

                if (data.type === 'title') {
                    slideHtml = `<div class="slide flex-col items-center justify-center p-8 text-center" data-slide-index="${index}">
                        <h1 class="text-8xl md:text-9xl font-bold text-gray-800 mb-16">${data.title}</h1>
                        <div class="mt-8 text-4xl md:text-5xl text-gray-600">
                           <p>${data.author}</p>
                           <p class="mt-2 font-semibold text-gray-700">${data.author_detail}</p>
                        </div>
                    </div>`;
                } else if (data.type === 'toc') {
                    slideHtml = `<div class="slide flex-col items-center justify-center p-8" data-slide-index="${index}">
                        <h2 class="text-7xl md:text-8xl font-bold mb-16 text-gray-800">${data.title}</h2>
                        <ul class="grid grid-cols-1 md:grid-cols-2 gap-x-24 gap-y-10 text-4xl md:text-5xl text-gray-700">
                            ${data.items.map((item, i) => `<li class="toc-item flex items-center" data-goto-slide="${(i * 2) + 2}"><span class="text-gray-500 font-bold mr-6">${i + 1}.</span>${item}</li>`).join('')}
                        </ul></div>`;
                } else if (data.type === 'problem_detail') {
                    const detailButtonHtml = data.problemId ? `
                        <div class="absolute top-8 right-12">
                            <button onclick="openModal('${data.problemId}')" class="bg-sky-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-sky-700 transition-colors shadow-md">
                                자세히 보기
                            </button>
                        </div>
                    ` : '';

                    slideHtml = `
                        <div class="slide flex-col p-8 md:p-12 bg-gray-50 relative" data-slide-index="${index}">
                            ${detailButtonHtml}
                            <h2 class="text-6xl md:text-7xl font-bold mb-10 text-gray-800 self-start">${data.title}</h2>
                            <div class="w-full flex-1 grid grid-rows-3 gap-8 overflow-hidden">
                                <div class="bg-white p-8 rounded-xl border border-gray-200 overflow-auto problem-detail-box shadow-sm">
                                    <h3 class="text-4xl font-semibold text-sky-700 mb-4">문제</h3>
                                    <p class="text-3xl text-gray-700 leading-relaxed whitespace-pre-line">${data.problem}</p>
                                </div>
                                <div class="bg-white p-8 rounded-xl border border-gray-200 overflow-auto problem-detail-box shadow-sm">
                                    <h3 class="text-4xl font-semibold text-sky-700 mb-4">입력</h3>
                                    <p class="text-3xl text-gray-700 leading-relaxed whitespace-pre-line">${data.input}</p>
                                </div>
                                <div class="bg-white p-8 rounded-xl border border-gray-200 overflow-auto problem-detail-box shadow-sm">
                                    <h3 class="text-4xl font-semibold text-sky-700 mb-4">출력</h3>
                                    <p class="text-3xl text-gray-700 leading-relaxed whitespace-pre-line">${data.output}</p>
                                </div>
                            </div>
                        </div>`;
                } else if (data.type === 'problem') {
                    const languages = ['java', 'python', 'javascript'];
                    let codeBlocksHtml = '';

                    languages.forEach(lang => {
                        const codeString = data.codes[lang] || '';
                        const splitMarker = '/*---SPLIT---*/';
                        const langSpecificCode = codeString.replace(/\/\/---SPLIT---|#---SPLIT---/g, splitMarker);

                        let innerHtml = '';
                        if (langSpecificCode.includes(splitMarker)) {
                            const parts = langSpecificCode.split(splitMarker);
                            innerHtml = `
                                <div class="grid grid-cols-2 gap-4 h-full">
                                    <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-lg p-4 text-2xl h-full overflow-auto">
                                        <pre><code class="language-${lang}">${parts[0].trim()}</code></pre>
                                    </div>
                                    <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-lg p-4 text-2xl h-full overflow-auto">
                                        <pre><code class="language-${lang}">${parts[1].trim()}</code></pre>
                                    </div>
                                </div>`;
                        } else {
                            innerHtml = `
                                <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-lg p-4 text-2xl h-full overflow-auto">
                                    <pre><code class="language-${lang}">${langSpecificCode.trim()}</code></pre>
                                </div>`;
                        }

                        codeBlocksHtml += `<div class="code-container h-full" data-lang="${lang}">${innerHtml}</div>`;
                    });

                    slideHtml = `
                        <div class="slide flex-col p-8 md:p-12" data-slide-index="${index}" data-is-problem="true">
                            <div class="flex-shrink-0">
                                <h2 class="text-6xl md:text-7xl font-bold mb-4 text-gray-800">${data.title}</h2>
                            </div>
                            <div class="flex-1 mt-4 flex flex-col min-h-0">
                                <div class="flex items-center justify-center space-x-6 mb-4">
                                    <span class="lang-indicator java text-4xl font-bold p-2 cursor-pointer">Java</span>
                                    <span class="lang-indicator python text-4xl font-bold p-2 cursor-pointer">Python</span>
                                    <span class="lang-indicator javascript text-4xl font-bold p-2 cursor-pointer">JavaScript</span>
                                </div>
                                <div class="flex-1 relative min-h-0">${codeBlocksHtml}</div>
                            </div>
                        </div>`;
                }
                presentationContainer.insertAdjacentHTML('beforeend', slideHtml);
            });
            document.querySelectorAll('pre code').forEach(block => {
                block.innerHTML = block.innerHTML.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                hljs.highlightElement(block);
            });
            document.querySelectorAll('.toc-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const slideIndex = parseInt(e.currentTarget.dataset.gotoSlide, 10);
                    if (!isNaN(slideIndex)) {
                        currentSlide = slideIndex;
                        currentLang = 0;
                        updateSlideState();
                    }
                });
            });
        }

        function updateSlideState() {
            const slides = document.querySelectorAll('.slide');
            slides.forEach((slide, index) => slide.classList.toggle('active', index === currentSlide));

            const activeSlide = slides[currentSlide];
            if (activeSlide && activeSlide.dataset.isProblem) {
                const languages = ['java', 'python', 'javascript'];
                const currentLangName = languages[currentLang];

                activeSlide.querySelectorAll('.lang-indicator').forEach((indicator, index) => {
                    const isActive = index === currentLang;
                    indicator.classList.toggle('text-sky-600', isActive);
                    indicator.classList.toggle('text-gray-300', !isActive);
                    indicator.style.transform = isActive ? 'scale(1.15)' : 'scale(1.0)';
                    indicator.onclick = () => {
                        currentLang = index;
                        updateSlideState();
                    };
                });

                activeSlide.querySelectorAll('.code-container').forEach(container => {
                    const isActive = container.dataset.lang === currentLangName;
                    container.classList.toggle('visible', isActive);
                });
            }
        }

        const goNext = () => {
            const activeSlide = document.querySelector('.slide.active');
            if (!activeSlide) return;

            if (activeSlide.dataset.isProblem && currentLang < 2) {
                currentLang++;
            } else {
                if (currentSlide < presentationData.length - 1) {
                    currentSlide++;
                    currentLang = 0;
                }
            }
            updateSlideState();
        };

        const goPrev = () => {
            const activeSlide = document.querySelector('.slide.active');
            if (!activeSlide) return;

            if (activeSlide.dataset.isProblem && currentLang > 0) {
                currentLang--;
            } else {
                if (currentSlide > 0) {
                    currentSlide--;
                    const prevSlide = document.querySelector(`[data-slide-index="${currentSlide}"]`);
                    if (prevSlide.dataset.isProblem) {
                        currentLang = 2;
                    } else {
                        currentLang = 0;
                    }
                }
            }
            updateSlideState();
        };

        // --- 모달 관련 로직 ---
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalContent = document.getElementById('modal-content');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const explanationContainer = document.getElementById('explanation-container');

        function openModal(problemId) {
            const data = explanationData[problemId];
            if (data) {
                let contentHtml = `<h1 class="text-5xl font-bold text-gray-800 mb-8">${data.title}</h1>`;
                data.steps.forEach(step => {
                    contentHtml += `
                        <div class="mb-8 bg-white p-6 rounded-2xl shadow-lg border border-gray-200">
                            <h2 class="text-3xl font-bold mb-4 flex items-center">
                                <span class="text-4xl mr-4">${step.icon}</span>
                                <span class="text-gray-500 mr-3">STEP ${step.step}:</span>
                                ${step.title}
                            </h2>
                            <div class="prose max-w-none prose-xl">
                                ${step.content || ''}
                            </div>
                    `;

                    if (step.code && step.code_explanation) {
                        contentHtml += `
                            <div class="mt-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-md p-4 text-lg h-full overflow-auto">
                                    <pre><code class="language-java">${step.code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>
                                 </div>
                                <div class="bg-gray-50 p-4 rounded-xl border">
                                    ${step.code_explanation}
                                </div>
                            </div>
                        `;
                    }
                    contentHtml += `</div>`;
                });

                explanationContainer.innerHTML = contentHtml;
                hljs.highlightAll();

                modalBackdrop.style.display = 'block';
                modalContent.style.display = 'block';
            }
        }

        function closeModal() {
            modalBackdrop.style.display = 'none';
            modalContent.style.display = 'none';
            explanationContainer.innerHTML = '';
        }

        modalCloseBtn.addEventListener('click', closeModal);
        modalBackdrop.addEventListener('click', closeModal);

        // --- 초기화 로직 ---
        document.addEventListener('DOMContentLoaded', () => {
            renderSlides();
            updateSlideState();
            document.addEventListener('keydown', e => {
                if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') goNext();
                if (e.key === 'ArrowLeft' || e.key === 'PageUp') goPrev();
                if (e.key === 'Escape') closeModal(); // ESC로 모달 닫기
            });
        });
    </script>
</body>

</html>