<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>알고리즘 10문제: Java, Python, JS 풀이 분석 (WEEK3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        /* 상세 설명 모달을 위한 스타일 */
        #modal-backdrop {
            display: none;
            /* 기본적으로 숨김 */
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 40;
        }

        #modal-content {
            display: none;
            /* 기본적으로 숨김 */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            height: 90vh;
            background-color: #f9fafb;
            /* bg-gray-50 */
            z-index: 50;
            overflow-y: auto;
        }

        .example-box pre {
            white-space: pre-wrap;
            word-break: break-all;
            background-color: #f3f4f6;
            /* bg-gray-100 */
            padding: 0.75rem;
            /* p-3 */
            border-radius: 0.5rem;
            /* rounded-lg */
            height: 100%;
            overflow-y: auto;
        }
    </style>
</head>

<body class="bg-white text-black">

    <!-- 메인 프레젠테이션 컨테이너 -->
    <div id="presentation-root" class="relative w-screen h-screen">
        <div id="presentation-container" class="w-full h-full bg-white flex flex-col overflow-hidden">
        </div>
    </div>

    <!-- 상세 설명을 위한 모달 UI -->
    <div id="modal-backdrop"></div>
    <div id="modal-content" class="p-4 sm:p-6 lg:p-8 rounded-2xl shadow-2xl">
        <button id="modal-close-btn"
            class="absolute top-4 right-6 text-5xl font-bold text-gray-500 hover:text-gray-800">&times;</button>
        <div id="explanation-container" class="max-w-7xl mx-auto">
            <!-- 동적 콘텐츠가 여기에 삽입됩니다. -->
        </div>
    </div>


    <script>
        // --- 데이터 시작 ---

        // 메인 슬라이드 데이터
        const presentationData = [
            // --- 표지 & 목차 ---
            {
                type: 'title',
                title: '알고리즘 10문제 (3주차)',
                author: '경성대학교 소프트웨어학과',
                author_detail: '2021663046 이건우'
            },
            {
                type: 'toc',
                title: '발표 순서 (3주차)',
                items: [
                    '수 찾기 (BOJ 1920)', '기타 레슨 (BOJ 2343)', '동전 0 (BOJ 11047)',
                    '카드 정렬하기 (BOJ 1715)', '회의실 배정 (BOJ 1931)', '잃어버린 괄호 (BOJ 1541)',
                    '소수 구하기 (BOJ 1929)', 'GCD(n, k) = 1 (BOJ 11689)', '최소공배수 (BOJ 1934)',
                    'Ax + By = C (BOJ 21568)'
                ]
            },
            // --- 문제 1: 이진 탐색 ---
            {
                type: 'problem_detail',
                title: '문제 1: 수 찾기 (BOJ 1920)',
                problem: 'N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.',
                input: '첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내야 한다. 모든 정수의 범위는 -2^31 보다 크거나 같고 2^31보다 작다.',
                output: 'M개의 줄에 답을 출력한다. 존재하면 1, 존재하지 않으면 0을 출력한다.',
                example_input_1: `5
4 1 5 2 3
5
1 3 7 9 5`,
                example_output_1: `1
1
0
0
1`
            },
            {
                type: 'problem',
                title: '알고리즘: 이진 탐색',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class bj1_1920 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int arr[] = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        Arrays.sort(arr);

        int m = Integer.parseInt(br.readLine());
        st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < m; i++) {
            int target = Integer.parseInt(st.nextToken());
            if (binarySearch(arr, target)) {
                sb.append(1).append("\\n");
            } else {
                sb.append(0).append("\\n");
            }
        }
        System.out.print(sb);
    }
    
    private static boolean binarySearch(int[] arr, int target) {
        int start = 0;
        int end = arr.length - 1;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (arr[mid] == target) return true;
            if (arr[mid] < target) start = mid + 1;
            else end = mid - 1;
        }
        return false;
    }
}`,
                    python: `import sys

def binary_search(arr, target):
    start, end = 0, len(arr) - 1
    while start <= end:
        mid = (start + end) // 2
        if arr[mid] == target:
            return 1
        elif arr[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return 0

n = int(sys.stdin.readline())
arr_n = sorted(list(map(int, sys.stdin.readline().split())))
m = int(sys.stdin.readline())
arr_m = list(map(int, sys.stdin.readline().split()))

for target in arr_m:
    print(binary_search(arr_n, target))`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const n = parseInt(input[0]);
const arrN = input[1].split(' ').map(Number).sort((a, b) => a - b);
const m = parseInt(input[2]);
const arrM = input[3].split(' ').map(Number);

function binarySearch(arr, target) {
    let start = 0;
    let end = arr.length - 1;
    while (start <= end) {
        let mid = Math.floor((start + end) / 2);
        if (arr[mid] === target) return 1;
        if (arr[mid] < target) start = mid + 1;
        else end = mid - 1;
    }
    return 0;
}

const result = arrM.map(target => binarySearch(arrN, target));
console.log(result.join('\\n'));`
                }
            },
            // --- 문제 2: 파라메트릭 서치 ---
            {
                type: 'problem_detail',
                title: '문제 2: 기타 레슨 (BOJ 2343)',
                problem: '강토는 자신의 기타 강의를 블루레이로 만들어 판매하려고 한다. 블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. 순서가 뒤바뀌는 경우에는 강의의 흐름이 끊겨, 학생들이 혼란에 빠질 수 있기 때문이다. 즉, i번 강의와 j번 강의를 같은 블루레이에 녹화하려면 i와 j 사이의 모든 강의도 같은 블루레이에 녹화해야 한다. 또한 M개의 블루레이를 모두 사용하지 않아도 된다. 이때, 블루레이의 크기(녹화 가능한 길이)를 최소로 하려고 한다.',
                input: '첫째 줄에 강의의 수 N (1 ≤ N ≤ 100,000)과 M (1 ≤ M ≤ N)이 주어진다. 다음 줄에는 강토의 기타 강의의 길이가 N개 주어진다. 강의의 길이는 10,000분을 넘지 않는 자연수이다.',
                output: '첫째 줄에 가능한 블루레이 크기중 최소를 출력한다.',
                example_input_1: `9 3
1 2 3 4 5 6 7 8 9`,
                example_output_1: `17`
            },
            {
                type: 'problem',
                title: '알고리즘: 파라메트릭 서치',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj2_2343 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        int[] lectures = new int[n];
        st = new StringTokenizer(br.readLine());
        long sum = 0;
        int maxLecture = 0;
        for (int i = 0; i < n; i++) {
            lectures[i] = Integer.parseInt(st.nextToken());
            sum += lectures[i];
            if (lectures[i] > maxLecture) maxLecture = lectures[i];
        }

        long left = maxLecture, right = sum;
        while (left <= right) {
            long mid = (left + right) / 2;
            int count = 1;
            long currentSum = 0;
            for (int lecture : lectures) {
                if (currentSum + lecture > mid) {
                    count++;
                    currentSum = lecture;
                } else {
                    currentSum += lecture;
                }
            }
            if (count <= m) right = mid - 1;
            else left = mid + 1;
        }
        System.out.println(left);
    }
}`,
                    python: `import sys

n, m = map(int, sys.stdin.readline().split())
lectures = list(map(int, sys.stdin.readline().split()))

left, right = max(lectures), sum(lectures)
result = right

while left <= right:
    mid = (left + right) // 2
    count = 1
    current_sum = 0
    for lecture in lectures:
        if current_sum + lecture > mid:
            count += 1
            current_sum = lecture
        else:
            current_sum += lecture
    
    if count <= m:
        result = mid
        right = mid - 1
    else:
        left = mid + 1

print(result)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const [n, m] = input[0].split(' ').map(Number);
const lectures = input[1].split(' ').map(Number);

let left = Math.max(...lectures);
let right = lectures.reduce((a, b) => a + b, 0);
let result = right;

while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    let count = 1;
    let currentSum = 0;
    for (const lecture of lectures) {
        if (currentSum + lecture > mid) {
            count++;
            currentSum = lecture;
        } else {
            currentSum += lecture;
        }
    }

    if (count <= m) {
        result = mid;
        right = mid - 1;
    } else {
        left = mid + 1;
    }
}

console.log(result);`
                }
            },
            // --- 문제 3: 그리디 ---
            {
                type: 'problem_detail',
                title: '문제 3: 동전 0 (BOJ 11047)',
                problem: '준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다. 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000) 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)',
                output: '첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.',
                example_input_1: `10 4200
1
5
10
50
100
500
1000
5000
10000
50000`,
                example_output_1: `6`
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj3_11047 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        int[] coins = new int[n];
        for (int i = 0; i < n; i++) {
            coins[i] = Integer.parseInt(br.readLine());
        }

        int count = 0;
        for (int i = n - 1; i >= 0; i--) {
            if (coins[i] <= k) {
                count += (k / coins[i]);
                k %= coins[i];
            }
        }
        System.out.println(count);
    }
}`,
                    python: `import sys

n, k = map(int, sys.stdin.readline().split())
coins = [int(sys.stdin.readline()) for _ in range(n)]

count = 0
for i in range(n - 1, -1, -1):
    if coins[i] <= k:
        count += k // coins[i]
        k %= coins[i]

print(count)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

let [n, k] = input[0].split(' ').map(Number);
const coins = [];
for (let i = 1; i <= n; i++) {
    coins.push(Number(input[i]));
}

let count = 0;
for (let i = n - 1; i >= 0; i--) {
    if (coins[i] <= k) {
        count += Math.floor(k / coins[i]);
        k %= coins[i];
    }
    if (k === 0) break;
}

console.log(count);`
                }
            },
            // --- 문제 4: 우선순위 큐 ---
            {
                type: 'problem_detail',
                title: '문제 4: 카드 정렬하기 (BOJ 1715)',
                problem: '정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.',
                output: '첫째 줄에 최소 비교 횟수를 출력한다.',
                example_input_1: `3
10
20
40`,
                example_output_1: `100`
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디 (우선순위 큐)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;

public class bj4_1715 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        PriorityQueue<Long> pq = new PriorityQueue<>();
        for (int i = 0; i < n; i++) {
            pq.add(Long.parseLong(br.readLine()));
        }

        long sum = 0;
        while (pq.size() > 1) {
            long temp1 = pq.poll();
            long temp2 = pq.poll();

            sum += temp1 + temp2;
            pq.add(temp1 + temp2);
        }

        System.out.println(sum);
    }
}`,
                    python: `import sys
import heapq

n = int(sys.stdin.readline())
cards = []
for _ in range(n):
    heapq.heappush(cards, int(sys.stdin.readline()))

total_sum = 0
while len(cards) > 1:
    temp1 = heapq.heappop(cards)
    temp2 = heapq.heappop(cards)

    current_sum = temp1 + temp2
    total_sum += current_sum
    heapq.heappush(cards, current_sum)

print(total_sum)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n').map(Number);
const n = input[0];
const cards = input.slice(1);

class MinHeap {
    constructor() { this.heap = []; }
    size() { return this.heap.length; }
    push(v) { this.heap.push(v); this.bubbleUp(); }
    pop() {
        const val = this.heap[0];
        this.heap[0] = this.heap.pop();
        if (this.size() > 0) this.bubbleDown();
        return val;
    }
    bubbleUp() {
        let i = this.size() - 1;
        while (i > 0) {
            const p = Math.floor((i - 1) / 2);
            if (this.heap[p] <= this.heap[i]) break;
            [this.heap[p], this.heap[i]] = [this.heap[i], this.heap[p]];
            i = p;
        }
    }
    bubbleDown() {
        let i = 0;
        while (true) {
            let l = 2*i + 1, r = 2*i + 2, s = i;
            if (l < this.size() && this.heap[l] < this.heap[s]) s = l;
            if (r < this.size() && this.heap[r] < this.heap[s]) s = r;
            if (s === i) break;
            [this.heap[s], this.heap[i]] = [this.heap[i], this.heap[s]];
            i = s;
        }
    }
}

const pq = new MinHeap();
for (const card of cards) pq.push(card);
let totalSum = 0;
while (pq.size() > 1) {
    const s = pq.pop() + pq.pop();
    totalSum += s;
    pq.push(s);
}
console.log(totalSum);`
                }
            },
            // --- 문제 5: 그리디 ---
            {
                type: 'problem_detail',
                title: '문제 5: 회의실 배정 (BOJ 1931)',
                problem: '한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.',
                input: '첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2^31-1보다 작거나 같은 자연수 또는 0이다.',
                output: '첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.',
                example_input_1: `11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14`,
                example_output_1: `4`
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디 (정렬)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class bj5_1931 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[][] meetings = new int[n][2];

        for (int i = 0; i < n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            meetings[i][0] = Integer.parseInt(st.nextToken());
            meetings[i][1] = Integer.parseInt(st.nextToken());
        }

        Arrays.sort(meetings, (o1, o2) -> {
            if (o1[1] == o2[1]) {
                return o1[0] - o2[0];
            }
            return o1[1] - o2[1];
        });

        int count = 0;
        int endTime = 0;
        for (int i = 0; i < n; i++) {
            if (meetings[i][0] >= endTime) {
                endTime = meetings[i][1];
                count++;
            }
        }
        System.out.println(count);
    }
}`,
                    python: `import sys

n = int(sys.stdin.readline())
meetings = []
for _ in range(n):
    start, end = map(int, sys.stdin.readline().split())
    meetings.append((start, end))

meetings.sort(key=lambda x: (x[1], x[0]))

count = 0
end_time = 0
for meeting in meetings:
    if meeting[0] >= end_time:
        end_time = meeting[1]
        count += 1

print(count)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const n = Number(input[0]);
const meetings = [];
for (let i = 1; i <= n; i++) {
    meetings.push(input[i].split(' ').map(Number));
}

meetings.sort((a, b) => {
    if (a[1] === b[1]) {
        return a[0] - b[0];
    }
    return a[1] - b[1];
});

let count = 0;
let endTime = 0;
for (const meeting of meetings) {
    if (meeting[0] >= endTime) {
        endTime = meeting[1];
        count++;
    }
}

console.log(count);`
                }
            },
            // --- 문제 6: 그리디 ---
            {
                type: 'problem_detail',
                title: '문제 6: 잃어버린 괄호 (BOJ 1541)',
                problem: '세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다. 그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.',
                input: '첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 식의 길이는 50보다 작거나 같다.',
                output: '첫째 줄에 정답을 출력한다.',
                example_input_1: `55-50+40`,
                example_output_1: `-35`
            },
            {
                type: 'problem',
                title: '알고리즘: 그리디 (문자열 처리)',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class bj6_1541 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] subtraction = br.readLine().split("-");
        int result = 0;

        for (int i = 0; i < subtraction.length; i++) {
            int tempSum = 0;
            String[] addition = subtraction[i].split("\\\\+");
            for (String s : addition) {
                tempSum += Integer.parseInt(s);
            }

            if (i == 0) {
                result += tempSum;
            } else {
                result -= tempSum;
            }
        }
        System.out.println(result);
    }
}`,
                    python: `import sys

expression = sys.stdin.readline().strip().split("-")
result = 0

first_part = list(map(int, expression[0].split("+")))
result += sum(first_part)

for i in range(1, len(expression)):
    other_part = list(map(int, expression[i].split("+")))
    result -= sum(other_part)

print(result)`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim();

const parts = input.split('-');
let result = 0;

const firstPartSum = parts[0].split('+').map(Number).reduce((a, b) => a + b, 0);
result += firstPartSum;

for (let i = 1; i < parts.length; i++) {
    const otherPartSum = parts[i].split('+').map(Number).reduce((a, b) => a + b, 0);
    result -= otherPartSum;
}

console.log(result);`
                }
            },
            // --- 문제 7: 소수 ---
            {
                type: 'problem_detail',
                title: '문제 7: 소수 구하기 (BOJ 1929)',
                problem: 'M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.',
                input: '첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M과 N사이의 소수가 하나 이상 있는 입력만 주어진다.',
                output: '한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.',
                example_input_1: `3 16`,
                example_output_1: `3
5
7
11
13`
            },
            {
                type: 'problem',
                title: '알고리즘: 에라토스테네스의 체',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj7_1929 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int m = Integer.parseInt(st.nextToken());
        int n = Integer.parseInt(st.nextToken());

        boolean[] isPrime = new boolean[n + 1];
        for (int i = 2; i <= n; i++) isPrime[i] = true;

        for (int i = 2; i * i <= n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = m; i <= n; i++) {
            if (isPrime[i]) sb.append(i).append('\\n');
        }
        System.out.print(sb);
    }
}`,
                    python: `import sys
import math

m, n = map(int, sys.stdin.readline().split())

is_prime = [True] * (n + 1)
if n >= 0:
    if len(is_prime) > 0: is_prime[0] = False
    if len(is_prime) > 1: is_prime[1] = False

for i in range(2, int(math.sqrt(n)) + 1):
    if is_prime[i]:
        for j in range(i * i, n + 1, i):
            is_prime[j] = False

for i in range(m, n + 1):
    if is_prime[i]:
        print(i)`,
                    javascript: `const fs = require('fs');
const [m, n] = fs.readFileSync('/dev/stdin').toString().trim().split(' ').map(Number);

const isPrime = new Array(n + 1).fill(true);
isPrime[0] = false;
isPrime[1] = false;

for (let i = 2; i * i <= n; i++) {
    if (isPrime[i]) {
        for (let j = i * i; j <= n; j += i) {
            isPrime[j] = false;
        }
    }
}

const result = [];
for (let i = m; i <= n; i++) {
    if (isPrime[i]) result.push(i);
}
console.log(result.join('\\n'));`
                }
            },
            // --- 문제 8: 오일러 피 ---
            {
                type: 'problem_detail',
                title: '문제 8: GCD(n, k) = 1 (BOJ 11689)',
                problem: '자연수 n이 주어졌을 때, GCD(n, k) = 1을 만족하는 자연수 1 ≤ k ≤ n의 개수를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 자연수 n (1 ≤ n ≤ 10^12)이 주어진다.',
                output: 'GCD(n, k) = 1을 만족하는 자연수 1 ≤ k ≤ n의 개수를 출력한다.',
                problemId: 'bj11689', // 각 문제에 대한 고유 ID 추가
                example_input_1: `10`,
                example_output_1: `4`
            },
            {
                type: 'problem',
                title: '알고리즘: 오일러 피 함수',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class bj8_11689 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine());
        long phi = n;

        for (long p = 2; p * p <= n; p++) {
            if (n % p == 0) {
                phi = phi / p * (p - 1);
                while (n % p == 0) {
                    n /= p;
                }
            }
        }

        if (n > 1) {
            phi = phi / n * (n - 1);
        }

        System.out.println(phi);
    }
}`,
                    python: `import sys

n = int(sys.stdin.readline())
phi = n
p = 2
while p * p <= n:
    if n % p == 0:
        phi = phi // p * (p - 1)
        while n % p == 0:
            n //= p
    p += 1

if n > 1:
    phi = phi // n * (n - 1)

print(phi)`,
                    javascript: `const fs = require('fs');
let n = BigInt(fs.readFileSync('/dev/stdin').toString().trim());

let phi = n;
for (let p = 2n; p * p <= n; p++) {
    if (n % p === 0n) {
        phi = phi / p * (p - 1n);
        while (n % p === 0n) {
            n /= p;
        }
    }
}

if (n > 1n) {
    phi = phi / n * (n - 1n);
}

console.log(phi.toString());`
                }
            },
            // --- 문제 9: 최소공배수 ---
            {
                type: 'problem_detail',
                title: '문제 9: 최소공배수 (BOJ 1934)',
                problem: '두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)',
                output: '첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 각각 출력한다.',
                example_input_1: `3
1 45000
6 10
13 17`,
                example_output_1: `45000
30
221`
            },
            {
                type: 'problem',
                title: '알고리즘: 유클리드 호제법',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj9_1934 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < t; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            long result = (long) a * b / gcd(a, b);
            sb.append(result).append('\\n');
        }
        System.out.print(sb);
    }

    private static int gcd(int a, int b) {
        while (b != 0) {
            int r = a % b;
            a = b;
            b = r;
        }
        return a;
    }
}`,
                    python: `import sys
import math

def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return (a * b) // gcd(a, b)

t = int(sys.stdin.readline())
for _ in range(t):
    a, b = map(int, sys.stdin.readline().split())
    print(lcm(a, b))`,
                    javascript: `const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\\n');

const t = Number(input[0]);

function gcd(a, b) {
    while (b) { [a, b] = [b, a % b]; }
    return a;
}

function lcm(a, b) {
    return (a * b) / gcd(a, b);
}

let result = '';
for (let i = 1; i <= t; i++) {
    const [a, b] = input[i].split(' ').map(Number);
    result += lcm(a, b) + '\\n';
}

console.log(result.trim());`
                }
            },
            // --- 문제 10: 확장 유클리드 ---
            {
                type: 'problem_detail',
                title: '문제 10: Ax + By = C (BOJ 21568)',
                problem: '정수 a, b, c가 주어졌을 때, ax + by = c를 만족하는 정수 x, y를 구하는 프로그램을 작성하시오.',
                input: '첫째 줄에 세 정수 a, b, c가 주어진다. (1 ≤ a, b, c ≤ 1,000,000,000) 문제의 답이 항상 존재하는 경우만 입력으로 주어진다.',
                output: 'ax + by = c를 만족하는 정수 x, y를 순서대로 공백으로 구분해 출력한다. 답이 여러 개인 경우 아무거나 하나 출력한다.',
                example_input_1: `2 3 5`,
                example_output_1: `1 1`
            },
            {
                type: 'problem',
                title: '알고리즘: 확장 유클리드 호제법',
                codes: {
                    java: `import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class bj10_21568 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        long a = Long.parseLong(st.nextToken());
        long b = Long.parseLong(st.nextToken());
        long c = Long.parseLong(st.nextToken());

        long[] result = extendedGcd(a, b);
        long gcd = result[0];
        long x0 = result[1];
        
        if (c % gcd != 0) {
             // 답이 항상 존재하는 경우만 입력으로 주어짐
        } else {
            long k = c / gcd;
            System.out.println(x0 * k + " " + (c - a * x0 * k) / b);
        }
    }

    private static long[] extendedGcd(long a, long b) {
        if (b == 0) return new long[] { a, 1, 0 };
        long[] temp = extendedGcd(b, a % b);
        long gcd = temp[0];
        long x = temp[2];
        long y = temp[1] - (a / b) * temp[2];
        return new long[] { gcd, x, y };
    }
}`,
                    python: `import sys

def extended_gcd(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x1, y1 = extended_gcd(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return gcd, x, y

a, b, c = map(int, sys.stdin.readline().split())
gcd_val, x0, y0 = extended_gcd(a, b)

k = c // gcd_val
print(x0 * k, y0 * k)`,
                    javascript: `const fs = require('fs');
const [a, b, c] = fs.readFileSync('/dev/stdin').toString().trim().split(' ').map(BigInt);

function extendedGcd(a, b) {
    if (b === 0n) {
        return [a, 1n, 0n];
    }
    const [gcd, x1, y1] = extendedGcd(b, a % b);
    const x = y1;
    const y = x1 - (a / b) * y1;
    return [gcd, x, y];
}

const [gcd_val, x0, y0] = extendedGcd(a, b);

const k = c / gcd_val;
console.log(\`\${x0 * k} \${y0 * k}\`);`
                }
            }
        ];

        // 상세 설명 데이터
        const explanationData = {
            'bj11689': {
                title: 'BOJ 11689: 서로소는 몇 개일까? - 오일러 피 함수 완전 정복',
                steps: [
                    {
                        step: 1,
                        icon: '🧱',
                        title: "문제 이해하기 - '서로소'란?",
                        content: `
                <div class="grid md:grid-cols-2 gap-8 items-center">
                    <div class="text-xl space-y-4 text-slate-700">
                        <p>이 문제에서 <strong>'서로소'</strong>는 수학 용어를 의미합니다.</p>
                        <p class="font-semibold bg-sky-50 p-4 rounded-lg border border-sky-200">두 숫자의 공통된 약수가 1밖에 없는 관계를 말해요.</p>
                        <p>예를 들어, <strong>6</strong>(약수: 1,2,3,6)과 <strong>35</strong>(약수: 1,5,7,35)는 공통 약수가 1뿐이므로 '서로소 '입니다.</p>
                    </div>
                    <div class="bg-slate-50 p-6 rounded-lg border">
                        <h3 class="font-bold text-2xl text-slate-800 mb-3">블록 비유</h3>
                        <ul class="list-disc list-inside text-lg space-y-2">
                            <li><strong>숫자 6</strong> = <span class="font-bold text-red-500">'2번'</span> 블록 + <span class="font-bold text-blue-500">'3번'</span> 블록</li>
                            <li><strong>숫자 10</strong> = <span class="font-bold text-red-500">'2번'</span> 블록 + <span class="font-bold text-green-500">'5번'</span> 블록<br><span class="text-sm text-red-600 ml-4">➡️ '2번' 블록이 겹치니 서로소 아님!</span></li>
                            <li><strong>숫자 35</strong> = <span class="font-bold text-green-500">'5번'</span> 블록 + <span class="font-bold text-yellow-500">'7번'</span> 블록<br><span class="text-sm text-green-600 ml-4">➡️ 6과 35는 겹치는 블록이 없으니 서로소!</span></li>
                        </ul>
                    </div>
                </div>
            `
                    },
                    {
                        step: 2,
                        icon: '💡',
                        title: '어떻게 풀까? - 발상의 전환',
                        content: `
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="bg-red-50 p-6 rounded-lg border border-red-200">
                        <h3 class="font-bold text-2xl text-red-700 mb-3">단순한 방법 (그리고 한계) 💀</h3>
                        <p class="text-xl text-slate-700">1부터 N까지 모든 수에 대해 최대공약수를 구해 서로소인지 확인하면 됩니다.</p>
                        <p class="mt-4 text-center font-bold text-2xl text-red-600 p-4 bg-white rounded-lg shadow-inner">🚨 N이 1조면? 시간 초과! 🚨</p>
                    </div>
                    <div class="bg-green-50 p-6 rounded-lg border border-green-200">
                        <h3 class="font-bold text-2xl text-green-700 mb-3">오일러의 아이디어 ✨</h3>
                        <p class="text-xl text-slate-700">"서로소를 세지 말고, <br><strong>전체에서 서로소가 아닌 애들을 쫓아내자!</strong>"</p>
                        <p class="mt-4 text-xl font-semibold">서로소가 아닌 애들 = N과 공통된 소인수를 가진 숫자들.</p>
                    </div>
                </div>
            `
                    },
                    {
                        step: 3,
                        icon: '🧪',
                        title: '아이디어를 공식으로! (feat. 체)',
                        content: `
                <p class="text-xl text-slate-600 mb-6">N=30 (소인수: 2, 3, 5)을 예로 들어, '체로 거르는' 과정을 따라가 봅시다.</p>
                <div class="bg-slate-50 p-6 rounded-xl border space-y-4">
                    <div class="flex items-center space-x-4">
                        <div class="bg-slate-200 text-slate-800 text-2xl font-bold rounded-full w-16 h-16 flex items-center justify-center">30</div>
                        <div class="text-xl text-slate-700"><strong>시작:</strong> 30개의 숫자가 있습니다.</div>
                    </div>
                    <div class="flex items-center space-x-4 pl-4 border-l-4 border-red-300">
                        <div class="text-2xl font-bold text-red-500">× (1 - <sup>1</sup>&frasl;<sub>2</sub>)</div>
                        <div>
                            <p class="text-xl text-slate-700"><strong>1차 필터링:</strong> 2의 배수(절반)를 걷어냅니다. 남은 비율은 1/2.</p>
                            <p class="text-lg font-mono text-slate-500">30 × (1/2) = 15개가 남습니다.</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-4 pl-4 border-l-4 border-blue-300">
                        <div class="text-2xl font-bold text-blue-500">× (1 - <sup>1</sup>&frasl;<sub>3</sub>)</div>
                        <div>
                            <p class="text-xl text-slate-700"><strong>2차 필터링:</strong> 남은 숫자들 중 3의 배수(1/3)를 또 걷어냅니다. 남는 비율은 2/3.</p>
                            <p class="text-lg font-mono text-slate-500">15 × (2/3) = 10개가 남습니다.</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-4 pl-4 border-l-4 border-green-300">
                        <div class="text-2xl font-bold text-green-500">× (1 - <sup>1</sup>&frasl;<sub>5</sub>)</div>
                        <div>
                            <p class="text-xl text-slate-700"><strong>3차 필터링:</strong> 또 남은 숫자들 중 5의 배수(1/5)를 걷어냅니다. 남는 비율은 4/5.</p>
                            <p class="text-lg font-mono text-slate-500">10 × (4/5) = 8개가 남습니다.</p>
                        </div>
                    </div>
                </div>
                <p class="text-center text-xl mt-6 p-4 bg-teal-50 border border-teal-200 rounded-lg">
                    이 과정을 합치면, <strong><code class="text-teal-700">30 × (1 - 1/2) × (1 - 1/3) × (1 - 1/5) = 8</code></strong> 이라는 공식이 자연스럽게 완성됩니다!
                </p>
            `
                    },
                    {
                        step: 4,
                        icon: '📜',
                        title: '공식을 코드로 변환하기',
                        content: `
                 <div class="grid md:grid-cols-2 gap-8 items-center">
                    <div>
                        <h3 class="font-bold text-2xl text-slate-800 mb-3">오일러 피(φ) 함수 공식</h3>
                        <p class="text-xl text-slate-700 mb-4">방금 우리가 유도한 공식의 일반적인 형태입니다.</p>
                        <div class="bg-slate-50 p-6 rounded-lg border text-center">
                            <p class="font-serif text-3xl font-semibold text-slate-800">
                                φ(n) = n × (1 - <sup>1</sup>&frasl;<sub>p₁</sub>) × (1 - <sup>1</sup>&frasl;<sub>p₂</sub>) × ...
                            </p>
                            <p class="text-base text-slate-500 mt-2">(여기서 p₁, p₂ 등은 n의 각 소인수입니다)</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="font-bold text-2xl text-slate-800 mb-3">컴퓨터를 위한 공식 변환</h3>
                        <p class="text-xl text-slate-700 mb-4">컴퓨터는 분수 계산을 싫어하죠. 그래서 공식을 정수 계산이 가능하게 살짝 바꿉니다.</p>
                        <div class="bg-slate-50 p-4 rounded-lg border text-lg space-y-2">
                           <p>원래 계산: <code class="bg-slate-200 px-2 py-1 rounded">phi = phi * (1 - 1/p)</code></p>
                           <p>통분하기: <code class="bg-slate-200 px-2 py-1 rounded">phi = phi * ((p-1)/p)</code></p>
                           <p>순서 바꾸기: <code class="bg-slate-200 px-2 py-1 rounded">phi = (phi / p) * (p-1)</code></p>
                           <p class="font-bold text-purple-700 text-center pt-2">이게 바로 코드에 쓰인 형태입니다!</p>
                        </div>
                    </div>
                </div>
            `
                    },
                    {
                        step: 5,
                        icon: '💻',
                        title: '코드와 원리 최종 연결',
                        content: `
                 <p class="text-xl text-slate-600 mb-6">변환된 공식을 이제 코드로 구현해봅시다. 핵심은 <strong>"N의 소인수(p)를 찾고, 변환된 공식으로 결과(phi)를 갱신하는 것"</strong> 입니다.</p>
            `,
                        code: `// 1. 결과(phi)를 n으로 초기화
long phi = n;

// 2. n의 소인수 p를 찾기 위한 여정
for (long p = 2; p * p <= n; p++) {
    
    // 3. p가 n의 소인수가 맞다면?
    if (n % p == 0) {
        
        // 4. 변환된 공식 적용!
        phi = phi / p * (p - 1);

        // 5. n에서 p를 완전히 제거 (중요!)
        while (n % p == 0) {
            n /= p;
        }
    }
}
// 6. 마지막 남은 소인수 처리
if (n > 1) {
    phi = phi / n * (n - 1);
}`,
                        code_explanation: `
                <div class="space-y-3 text-lg">
                    <div class="p-3 bg-slate-50 rounded-md border"><strong>1. 초기 설정:</strong> 전체 학생 수(n)로 시작합니다.</div>
                    <div class="p-3 bg-slate-50 rounded-md border"><strong>2. 소인수 탐색:</strong> 2부터 차례대로 \`n\`을 나눌 수 있는지 검사합니다. (p*p <= n 은 효율을 위함)</div>
                    <div class="p-3 bg-slate-50 rounded-md border"><strong>3. 소인수 발견:</strong> \`n\`이 \`p\`로 나누어 떨어진다면, \`p\`는 \`n\`의 소인수입니다!</div>
                    <div class="p-3 bg-purple-50 rounded-md border border-purple-300"><strong>4. 공식 적용:</strong> 서로소가 아닌 \`p\`의 배수들을 걷어냅니다. <code>(결과 / p) * (p-1)</code></div>
                    <div class="p-3 bg-amber-50 rounded-md border border-amber-300"><strong>5. 소인수 제거(청소):</strong> <strong>가장 중요!</strong> \`n\`에서 \`p\`라는 재료를 완전히 소진시켜, \`p\`의 다른 배수(예: 4, 6)가 실수로 검사되는 것을 막습니다.</div>
                    <div class="p-3 bg-slate-50 rounded-md border"><strong>6. 최종 처리:</strong> \`while\`문으로 다 정리하고도 \`n\`이 1보다 크다면, 그 자체가 마지막 소인수이므로 한 번 더 공식을 적용해줍니다.</div>
                </div>
            `
                    }
                ]
            }
        };

        // --- 메인 스크립트 로직 ---

        const presentationContainer = document.getElementById('presentation-container');
        let currentSlide = 0;
        let currentLang = 0; // 0: Java, 1: Python, 2: JS

        function renderSlides() {
            presentationContainer.innerHTML = '';
            presentationData.forEach((data, index) => {
                let slideHtml = '';

                if (data.type === 'title') {
                    slideHtml = `<div class="slide flex-col items-center justify-center p-8 text-center" data-slide-index="${index}">
                        <h1 class="text-8xl md:text-9xl font-bold text-gray-800 mb-16">${data.title}</h1>
                        <div class="mt-8 text-4xl md:text-5xl text-gray-600">
                           <p>${data.author}</p>
                           <p class="mt-2 font-semibold text-gray-700">${data.author_detail}</p>
                        </div>
                    </div>`;
                } else if (data.type === 'toc') {
                    slideHtml = `<div class="slide flex-col items-center justify-center p-8" data-slide-index="${index}">
                        <h2 class="text-7xl md:text-8xl font-bold mb-16 text-gray-800">${data.title}</h2>
                        <ul class="grid grid-cols-1 md:grid-cols-2 gap-x-24 gap-y-10 text-4xl md:text-5xl text-gray-700">
                            ${data.items.map((item, i) => `<li class="toc-item flex items-center" data-goto-slide="${(i * 2) + 2}"><span class="text-gray-500 font-bold mr-6">${i + 1}.</span>${item}</li>`).join('')}
                        </ul></div>`;
                } else if (data.type === 'problem_detail') {
                    const detailButtonHtml = data.problemId ? `
                        <div class="absolute top-8 right-12">
                            <button onclick="openModal('${data.problemId}')" class="bg-sky-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-sky-700 transition-colors shadow-md">
                                자세히 보기
                            </button>
                        </div>
                    ` : '';

                    slideHtml = `
                        <div class="slide flex-col p-8 md:p-12 bg-gray-50 relative" data-slide-index="${index}">
                             ${detailButtonHtml}
                            <h2 class="text-5xl md:text-6xl font-bold mb-8 text-gray-800 self-start">${data.title}</h2>
                            <div class="w-full flex-1 grid grid-cols-1 lg:grid-cols-5 gap-6 overflow-hidden">
                                
                                <div class="lg:col-span-3 bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col">
                                    <h3 class="text-3xl font-semibold text-sky-700 mb-4 flex-shrink-0">문제 설명</h3>
                                    <div class="overflow-auto problem-detail-box flex-1">
                                      <p class="text-2xl text-gray-700 leading-relaxed whitespace-pre-line">${data.problem}</p>
                                    </div>
                                </div>
                                
                                <div class="lg:col-span-2 flex flex-col gap-6">
                                    <div class="flex-1 bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col">
                                        <h3 class="text-3xl font-semibold text-sky-700 mb-4 flex-shrink-0">입출력 형식</h3>
                                        <div class="grid grid-cols-1 gap-4 overflow-auto problem-detail-box flex-1">
                                            <div>
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">입력</h4>
                                                <p class="text-xl text-gray-600 leading-relaxed whitespace-pre-line">${data.input}</p>
                                            </div>
                                            <hr class="my-2">
                                            <div>
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">출력</h4>
                                                <p class="text-xl text-gray-600 leading-relaxed whitespace-pre-line">${data.output}</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="flex-1 bg-white p-6 rounded-xl border border-gray-200 shadow-sm flex flex-col">
                                        <h3 class="text-3xl font-semibold text-sky-700 mb-4 flex-shrink-0">예제</h3>
                                        <div class="grid grid-cols-2 gap-4 flex-1 overflow-hidden">
                                            <div class="example-box">
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">입력</h4>
                                                <pre class="text-xl">${data.example_input_1 || ''}</pre>
                                            </div>
                                            <div class="example-box">
                                                <h4 class="text-2xl font-semibold text-gray-600 mb-2">출력</h4>
                                                <pre class="text-xl">${data.example_output_1 || ''}</pre>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>`;

                } else if (data.type === 'problem') {
                    const languages = ['java', 'python', 'javascript'];
                    let codeBlocksHtml = '';

                    languages.forEach(lang => {
                        const codeString = data.codes[lang] || '';
                        const splitMarker = '/*---SPLIT---*/';
                        const langSpecificCode = codeString.replace(/\/\/---SPLIT---|#---SPLIT---/g, splitMarker);

                        let innerHtml = '';
                        if (langSpecificCode.includes(splitMarker)) {
                            const parts = langSpecificCode.split(splitMarker);
                            innerHtml = `
                                <div class="grid grid-cols-2 gap-4 h-full">
                                    <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-lg p-4 text-2xl h-full overflow-auto">
                                        <pre><code class="language-${lang}">${parts[0].trim()}</code></pre>
                                    </div>
                                    <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-lg p-4 text-2xl h-full overflow-auto">
                                        <pre><code class="language-${lang}">${parts[1].trim()}</code></pre>
                                    </div>
                                </div>`;
                        } else {
                            innerHtml = `
                                <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-lg p-4 text-2xl h-full overflow-auto">
                                    <pre><code class="language-${lang}">${langSpecificCode.trim()}</code></pre>
                                </div>`;
                        }

                        codeBlocksHtml += `<div class="code-container h-full" data-lang="${lang}">${innerHtml}</div>`;
                    });

                    slideHtml = `
                        <div class="slide flex-col p-8 md:p-12" data-slide-index="${index}" data-is-problem="true">
                            <div class="flex-shrink-0">
                                <h2 class="text-6xl md:text-7xl font-bold mb-4 text-gray-800">${data.title}</h2>
                            </div>
                            <div class="flex-1 mt-4 flex flex-col min-h-0">
                                <div class="flex items-center justify-center space-x-6 mb-4">
                                    <span class="lang-indicator java text-4xl font-bold p-2 cursor-pointer">Java</span>
                                    <span class="lang-indicator python text-4xl font-bold p-2 cursor-pointer">Python</span>
                                    <span class="lang-indicator javascript text-4xl font-bold p-2 cursor-pointer">JavaScript</span>
                                </div>
                                <div class="flex-1 relative min-h-0">${codeBlocksHtml}</div>
                            </div>
                        </div>`;
                }
                presentationContainer.insertAdjacentHTML('beforeend', slideHtml);
            });
            document.querySelectorAll('pre code').forEach(block => {
                block.innerHTML = block.innerHTML.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                hljs.highlightElement(block);
            });
            document.querySelectorAll('.toc-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const slideIndex = parseInt(e.currentTarget.dataset.gotoSlide, 10);
                    if (!isNaN(slideIndex)) {
                        currentSlide = slideIndex;
                        currentLang = 0;
                        updateSlideState();
                    }
                });
            });
        }

        function updateSlideState() {
            const slides = document.querySelectorAll('.slide');
            slides.forEach((slide, index) => slide.classList.toggle('active', index === currentSlide));

            const activeSlide = slides[currentSlide];
            if (activeSlide && activeSlide.dataset.isProblem) {
                const languages = ['java', 'python', 'javascript'];
                const currentLangName = languages[currentLang];

                activeSlide.querySelectorAll('.lang-indicator').forEach((indicator, index) => {
                    const isActive = index === currentLang;
                    indicator.classList.toggle('text-sky-600', isActive);
                    indicator.classList.toggle('text-gray-300', !isActive);
                    indicator.style.transform = isActive ? 'scale(1.15)' : 'scale(1.0)';
                    indicator.onclick = () => {
                        currentLang = index;
                        updateSlideState();
                    };
                });

                activeSlide.querySelectorAll('.code-container').forEach(container => {
                    const isActive = container.dataset.lang === currentLangName;
                    container.classList.toggle('visible', isActive);
                });
            }
        }

        const goNext = () => {
            const activeSlide = document.querySelector('.slide.active');
            if (!activeSlide) return;

            if (activeSlide.dataset.isProblem && currentLang < 2) {
                currentLang++;
            } else {
                if (currentSlide < presentationData.length - 1) {
                    currentSlide++;
                    currentLang = 0;
                }
            }
            updateSlideState();
        };

        const goPrev = () => {
            const activeSlide = document.querySelector('.slide.active');
            if (!activeSlide) return;

            if (activeSlide.dataset.isProblem && currentLang > 0) {
                currentLang--;
            } else {
                if (currentSlide > 0) {
                    currentSlide--;
                    const prevSlide = document.querySelector(`[data-slide-index="${currentSlide}"]`);
                    if (prevSlide.dataset.isProblem) {
                        currentLang = 2;
                    } else {
                        currentLang = 0;
                    }
                }
            }
            updateSlideState();
        };

        // --- 모달 관련 로직 ---
        const modalBackdrop = document.getElementById('modal-backdrop');
        const modalContent = document.getElementById('modal-content');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const explanationContainer = document.getElementById('explanation-container');

        function openModal(problemId) {
            const data = explanationData[problemId];
            if (data) {
                let contentHtml = `<h1 class="text-5xl font-bold text-gray-800 mb-8">${data.title}</h1>`;
                data.steps.forEach(step => {
                    contentHtml += `
                        <div class="mb-8 bg-white p-6 rounded-2xl shadow-lg border border-gray-200">
                            <h2 class="text-3xl font-bold mb-4 flex items-center">
                                <span class="text-4xl mr-4">${step.icon}</span>
                                <span class="text-gray-500 mr-3">STEP ${step.step}:</span>
                                ${step.title}
                            </h2>
                            <div class="prose max-w-none prose-xl">
                                ${step.content || ''}
                            </div>
                    `;

                    if (step.code && step.code_explanation) {
                        contentHtml += `
                            <div class="mt-6 grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <div class="code-block dark-scrollbar bg-[#282c34] rounded-xl shadow-md p-4 text-lg h-full overflow-auto">
                                    <pre><code class="language-java">${step.code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code></pre>
                                 </div>
                                <div class="bg-gray-50 p-4 rounded-xl border">
                                    ${step.code_explanation}
                                </div>
                            </div>
                        `;
                    }
                    contentHtml += `</div>`;
                });

                explanationContainer.innerHTML = contentHtml;
                hljs.highlightAll();

                modalBackdrop.style.display = 'block';
                modalContent.style.display = 'block';
            }
        }

        function closeModal() {
            modalBackdrop.style.display = 'none';
            modalContent.style.display = 'none';
            explanationContainer.innerHTML = '';
        }

        modalCloseBtn.addEventListener('click', closeModal);
        modalBackdrop.addEventListener('click', closeModal);

        // --- 초기화 로직 ---
        document.addEventListener('DOMContentLoaded', () => {
            renderSlides();
            updateSlideState();
            document.addEventListener('keydown', e => {
                if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') goNext();
                if (e.key === 'ArrowLeft' || e.key === 'PageUp') goPrev();
                if (e.key === 'Escape') closeModal(); // ESC로 모달 닫기
            });
        });
    </script>
</body>

</html>